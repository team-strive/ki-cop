Sehr geehrte Podcast-Hörerin, sehr geehrter Podcast-Hörer, hiermit bewerben wir uns als dein nächster Arbeitgeber.


Ja, ich weiß schon, dass das normalerweise andersrum läuft, aber ich finde, dass sich Unternehmen heutzutage durchaus etwas reinhängen müssen, wenn es um neue Mitarbeitende geht.


Falls du also Scrum Master bist oder viel Erfahrung hast mit Fullstack, Backend oder Frontend Entwicklung, dann freue ich mich über eine kurze Nachricht an jobs at branded.dev und dann schicke ich super gerne unsere Bewerbungsunterlagen einschließlich Anschreiben, Lebenslauf und Fotos zu dir.


Bis hoffentlich bald und mit den allerbesten Grüßen von deinen neuen Kolleginnen und Kollegen von Branded.


Hallo und herzlich willkommen zu Episode 3 der zweiten Staffel von Schwarz-Kote-Gold.


Jetzt wird es langsam zum Zungenbrecher.


Hallo Bodo, hallo Frederik.


Hallo.


Hallo.


Man merkt, es wird langsam Frühling, weil ich kann mein Display nicht mehr ganz so gut ablesen.


Ich muss hier echt schon gucken, dass ich den Bildschirm richtig stehen habe.


Dabei ist gar noch nicht mal so sonnig.


Ich wollte mich eigentlich angewöhnen, immer Hallo Jürgen zu sagen, Hallo Frederik.


Ja, das ist gar nicht so einfach, wenn man Podcasts hört und es sind drei männliche Stimmen und man kennt die Leute nicht.


Tatsächlich hilft das ab und zu, die Namen zu sagen.


Es wirkt aber auf die Leute, wenn man sich so gegenüber sitzt, wirkt es im ersten Moment ein bisschen komisch.


Wie geht's euch?


Gut, ja.


Feiertag hinter uns, also wir nehmen am Brückentag auf, genau, um das zu sagen, zwischen Vatertag und Wochenende.


Der 19.


Mai 2023, für alle, die das in der Zukunft hören.


Genau, der Brückentag, an dem man Zeit hat, mal was, zum Beispiel einen Podcast aufzunehmen.


Stimmt, ja.


Es ist auch ziemlich ruhig gewesen auf der Straße und im Büro hier.


So wahnsinnig viele sind, glaube ich, heute nicht da, oder?


Kann das sein?


Im Büro nicht, aber auf der Straße war ganz schön was los.


Ja, habe ich auch gewundert.


Also die Mittagszeit, die Hölle los war auf mir.


Ja, ich habe die alle hier gerade beim Autowaschen, da vorne an der Waschanlage, da stand eine lange Schlange.


Also das scheint heute der Tag dafür zu sein.


Gut.


Kann wohl sein, ja.


Aber das ist ja gut, wenn wir schon beim Datum sind, dann können wir nämlich direkt anfangen mit unserer News-Sektion.


Habt ihr mir aktuelle Nachrichten mitgebracht?


Bodo, hast du was dabei?


Also ich habe nur gefunden, dass es erstens jetzt BART gibt von Google.


Das habe ich auch ausprobiert.


Es geht natürlich nur mit VPN, weil in Deutschland ist es ja noch quasi nicht veröffentlicht, weil deutsches Datenschutzrecht, keine Ahnung.


Das heißt, du musst also ein VPN nach UK zum Beispiel machen und dann kannst du BART auch ganz normal benutzen.


Du musst nichts zahlen.


So ähnlich wie ChatGPT auch.


Und ja, habe auch schon mal eine Frage gestellt, habe auch eine Antwort gekriegt, die so ähnlich ist wie die, die ich bei Chatshippe.de gekriegt habe.


Okay.


Ist ein bisschen flotter vielleicht von der Antwort-Reaktionszeit her.


Ja, also spannend auf jeden Fall.


Aber hast du schon was gesehen, was du jetzt woanders nicht gesehen hast, wo du sagen würdest, dafür wird es sich lohnen, dass man umsteigt?


Im Gegenteil, ich habe jetzt bei ChatGPT gestern erst gesehen, dass man jetzt auch Plugins und die Suche verwenden kann.


Aber das habe ich zwar eingeschalten, aber ich hatte noch keine Gelegenheit, es wirklich zu benutzen.


Ich habe mal durch die Apps, also durch die Plugins durchgeblättert, die es so gibt.


Ah, okay.


Also da hat mich die Beschreibung etwas verwirrt, weil da stand ja, dass es selber entscheidet, welche Plugins es wann verwendet.


Deswegen habe ich mir gedacht, oh, sehe ich jetzt hier gar keine Liste, wo ich irgendwas auswählen kann?


Doch, man kann schon, es gibt eine Liste mit einer Kurzbeschreibung jeweils.


Dann habe ich die nur übersehen.


Ja, gibt es schon, ja.


Ja, ich hatte mich ja zwischenzeitlich komplett ausgesperrt.


Wir haben ja so virtuelle Kreditkarten, damit wir da die Proversion nutzen können.


Und da habe ich mir gedacht, naja, dann lösche ich jetzt meine beiden privaten Konten, die ich habe, und mache ein Geschäftskonto, lege ein neues an.


Und dann hat er gesagt, oh nee, ihre Telefonnummer wurde schon mehrfach irgendwie verwendet.


habe ich versucht, so eine Wegwerftelefonnummer zu verwenden, die man im Internet irgendwo sich klicken kann, und dann wurde ich nach drei Versuchen gesperrt.


Und dann habe ich meine zwei Accounts gelöscht, und meinen dritten konnte ich nicht anlegen, und dann war ich wie in der Steinzeit.


Konnte ich kein Chatshivity mehr benutzen.


Das ist wirklich bitter.


Frederik, hast du auch was Spannendes dabei?


Ja, ich habe ein tagesaktuelles Thema, also sogar minutenaktuell, das kam jetzt gerade rein, das beschäftigt uns auch in der Firma selber, also da geht es jetzt darum, Headline ist Apple verbietet Nutzung von JetTPT und GitHub Copilot, also bei sich intern, dass sie sich nicht mehr in die Karten gucken lassen.


Das ist ja bei uns auch ein Problem, wo wir noch beim Kunden eben in der Situation sind, wir wissen nicht, können wir es irgendwann, wird es denn kommen oder auch nicht oder nur eine intern trainierte KI.


genutzt werden, weil ja klar das Problem der Code-Hoheit dann verloren gehen würde, wenn jeder irgendwie Code reinhackt und Chat-GPT mal fragt, wie man den Code refactoren kann oder verbessert oder irgendwas, wenn da interne Codes veröffentlicht werden und das verbietet jetzt Apple tatsächlich.


Ja gut, beim Kunden ist es tatsächlich bei uns so, dass wir es natürlich nicht benutzen, logischerweise, weil es nicht explizit erlaubt ist.


Bei unserer Schwester GmbH, bei der Solutions, da ist es so, dass die den festen Plan haben, das zu benutzen und auch sich schon überlegt haben, ob das jetzt ein Problem ist, dass der Source-Code quasi dann möglicherweise Richtung Open AI wandert oder nicht.


Aber da wird es wohl bewusst in Kauf genommen.


Da muss man ja dazu sagen, das ist ja dann der eigene Code.


Genau, die Solutions hat den eigenen Source-Code.


Da wird es so eingeschätzt, dass der Vorteil, den der Co-Pilot bietet, dass der größer ist, als dass man da jetzt vielleicht den einen oder anderen Codeschnipsel irgendwie weitergibt.


Also das ist super spannend.


Wir waren ja vorletzte Woche bei dem KI-Stammtisch in Ansbach am KI-Lehrstuhl.


Und der Professor Schachte war ja auch vorher schon bei uns im März mal auf dieser internen Entwicklerveranstaltung.


Und er hat noch, da ging es darum, da haben wir uns darüber unterhalten, ging es darum, im März meinte er so, naja, das wird jetzt alles dann auch in Richtung irgendwie lokale Sprachmodelle gehen, sodass man irgendwie lokal trainieren kann, dass man eben genau diese Probleme nicht hat, dass man da Code reinpackt und der sonst wohin geht, sondern dass das alles im lokalen Netzwerk irgendwie verbleibt.


Und er meinte damals, naja, das ist so eine Entwicklung.


Ich weiß die Zahlen nicht mehr ganz genau, aber er schätzt sowas zwischen zwei und vier Jahre oder so, sind wir davon entfernt.


Und wir haben uns dann sechs Wochen, acht Wochen später in Ansbach getroffen und er hat gesagt, oh, er hat sich grob verschätzt, also die zwei Jahre sind jetzt um.


Okay.


Das heißt, es gibt es jetzt schon?


Es gibt schon Open-Source-Modelle, die du selber bei dir laufen lassen kannst, die du selber trainieren kannst, die du selber, wobei selber trainieren weiß ich nicht, aber die du selber quasi noch


weiter trainieren und veredeln kannst quasi am Ende und die du selber nutzen kannst.


Ja, die sind halt noch nicht auf dem Niveau von einem JetGB T4.


Und du hast natürlich auch, bist du durch die Hardware limitiert, aber wenn du so ein, so ein, im Ansbach, im Rechner-Netzwerk haben sie da so Dinge laufen, da läuft irgendwie der JetPod, den sie auf der Webseite haben, läuft im eigenen Netzwerk mit eigenen Datenquellen.


Also super spannend, was da gerade passiert.


Ich weiß nicht, seid ihr in Kryptowährungen investiert?


Oder habt ihr euch damit schon ... War das für euch spannend?


Gar nicht?


Habt ihr das schon abgehackt, das Thema?


Oder nie angefangen?


Eigentlich schon.


Da steht Volatilität.


Sehr entsteppig.


Ich hab's eigentlich abgehackt.


Okay.


Es gab da jetzt nämlich neulich einen News und da ist mir kurz das Herz stehen geblieben.


Ich hab da noch ein bisschen was und ich hab mir irgendwann mal so ein Hardware-Wallet auch gekauft von der Firma Ledger.


Also, weil's ja ... Das ist ja so der Grundsatz, ne?


Du musst irgendwie deinen Key selber verwahren und am besten auch nicht irgendwie auf dem Rechner, sondern irgendwo offline.


Und das habe ich ganz brav gemacht und zwar war ich die Tage auf Reddit unterwegs und da habe ich gesehen, dass plötzlich alle auf dieser Firma Ledger irgendwie eintreschen und dass da irgendwie, dass das ja gar nicht geht und ganz schlimm.


Und da habe ich schon gedacht, oh Gott, hatten die jetzt irgendwie einen Breach und ist das irgendwie gefährlich, kann ich dieses Ding nicht mehr benutzen, sind meine Coins weg.


Und jetzt haben die aber alles, alles was dahinter steckt quasi, haben jetzt eine neue Funktion eingeführt.


weil sie quasi neue Nutzergruppen ansprechen wollen.


Also sie wollen es den Leuten leichter machen.


Das ist ja schon kompliziert nach wie vor.


So ein Hardware Wallet und Keys und so, da muss man schon... Also ich kann nicht von mir behaupten, dass ich das komplett verstanden habe, was ich da alles getan habe.


Und sie wollen es jetzt quasi so machen, dass sie dir das als Online-Dienst, als Service bieten, dass sie deinen Key verwahren für dich.


Was ja eigentlich so überhaupt nicht in dem Sinne von dem Produkt ist, das sie haben, aber sie machen es dann so, dass sie den aufsplitten in drei Teile, also Verschlüsseln aufsplitten und dann drei unterschiedliche Dienstleister irgendwie geben, um den dann für dich zu verwahren, dass du dir das bei Bedarf dann irgendwie wiederherstellen könntest, auch wenn du jetzt diesen Hardware-Key verlierst zum Beispiel.


Und da gab es einen Riesenaufschrei jetzt im Netz und alle dreschen auf diese Firma ein.


Und ich habe mir gedacht, Moment, das ist doch alles optional, kann ich ja auch einfach bleiben lassen.


Aber es ist gerade wirklich ein kleiner Shitstorm unterwegs.


Fand ich bemerkenswert zumindest.


Ja ja Shitstorms gehen schnell und dann schnell groß und laut und dann ist die Frage ist es dann wirklich so.


Tragisch oder ja aber wenn es so gegen so Grundprinzipien verstößt also so wo man sagt.


Man soll es eigentlich offline speichern und dann doch online dann kann ich so ein bisschen nachvollziehen dass man sagt.


Ja, also so hatte ich es wahrgenommen.


Prinzipiell war ja die Firma aber immer eine der Guten.


Also die machen ja Hardware-Wallets, du kannst deinen Key irgendwie selber verwalten und ja, das ist genau der richtige Weg.


Deswegen gehört ihr zu den Guten.


Und nachdem jetzt ja Elon Musk neulich schon die Seiten vom Guten zum Bösen gewechselt hat, ich finde es bemerkenswert, wie schnell das zurzeit umschlagen kann.


Ich sehe schon.


Das begeistert mich so.


Dieses ganze Blockchain-Thema, ehrlich gesagt, ich habe mich auch mal vor ein paar Jahren damit beschäftigt, habe auch mal so eine Wallet irgendwo angelegt und so, aber am Ende glaube ich, das ist irgendwie so ein Nischending.


Ich glaube nicht, dass da noch der große Run kommt.


Ja, ich bin da etwas hin- und hergerissen.


Das ist für mich so wie Briefmarkensammeln.


Ja, sicher, man kann Briefmarken sammeln und die werden auch mit der Zeit mehr wert.


So ist es bei diesen Kryptowährungen vielleicht auch.


Bei den meisten ja nicht, aber bei dem einen oder anderen.


Ja, also ich meine, dieses Blockchain war natürlich auch, und da habe ich auch die Diskussion neulich geführt mit jemandem, der jetzt bei KI den gleichen Trend sieht, dass man jetzt so den, man hat eine Technologie und jetzt versuchen alle, die auf alles draufzuwerfen und jedes Problem damit zu lösen.


Und dann habe ich versucht, ihm zu erklären, warum das jetzt bei KI anders ist als bei Blockchain.


Aber ich konnte es nicht vollends so.


Ich habe ein paar Argumente gefunden, aber ich konnte nicht überzeugen.


Also für mich ist es ganz klar was ganz anderes.


Für mich auch.


Ja.


Aber erklär mir mal warum.


Ja, wie gesagt, also diese Blockchain, das ist für mich, das ist eine Nischenlösung für ein Nischenproblem.


Also ich will ja nicht sagen, dass es dieses Problem nicht gibt.


Man kann ja nicht nur Kryptowährungen mit Blockchains machen, sondern man kann zum Beispiel auch so Verträge und sowas damit verifizieren und solche Dinge.


Aber das ist ein relativ enger Anwendungsbereich, vielleicht noch im juristischen, aber diese künstliche Intelligenz, das ist eine komplett andere Sache, weil das eben alle Bereiche des Lebens betrifft aus meiner Sicht und betreffen wird.


Das wird auch noch sehr schnell viel weitergehen.


Es gibt ja auch immense Fortschritte jetzt in der Roboterentwicklung, da wird das auch eine Rolle spielen wieder.


Und das wird jetzt alles die nächsten Monate, wahrscheinlich Tage,


Vielleicht Jahre wird das alles kommen und es wird ganz viel verändern in der ganzen Welt eigentlich, in der ganzen Gesellschaft.


Ja, davon sind wir, wie wir hier sitzen, überzeugt.


Aber jemand, der das nicht oder noch nicht so für sich verstanden hat, dem das zu erklären, es gibt halt noch keine KI-Killer-Anwendung jetzt gerade.


So, es ist alles noch so ein bisschen Spielkram.


Und von daher ist die Parallele, die sehe ich schon.


Ja.


Also die Killeranwendung wird natürlich der Haushaltsroboter sein.


Du musst aufpassen mit dem Begriff Killeranwendung.


Ja, okay, da muss man aufpassen, das stimmt.


Und ich denke nicht, dass das noch so weit weg ist jetzt.


Also der Unterschied, den ich sehe, und das war das eine Argument, das ich dann auch irgendwie anbringen konnte, war,


dass du bei Blockchain, das ist natürlich super abstrakt, und du konntest jetzt nichts damit wirklich anfangen.


Klar konntest du dich jetzt in Kryptowährung irgendwie einfuchsen, aber dann konntest du ja auch nicht damit irgendwo bezahlen.


Also du hattest keinen direkten Bezug dazu.


Und bei KI kann jetzt jeder einfach hingehen und kann das sofort ausprobieren.


Und jeder kann sehen, okay, das ist jetzt was Neues.


Und wer das nicht sehen kann,


Dem fehlt vielleicht ein bisschen die Fantasie oder der hat sich vorher zu wenig mit Technik beschäftigt.


Aber was da jetzt gerade passiert, das kann jeder für sich selber erleben.


Und in jedem Lebensbereich.


Und ob das jetzt ist, eine Reise zu planen nach Prag und sich schnell mal für eineinhalb Tage die interessantesten Besuchsstätten dort geben zu lassen, bis hin zu, man lässt sich irgendwie ein Code-Problem in der Softwareentwicklung lösen.


Das ist so breit.


Kein Vergleich.


Einfach von der Anwendungsbreite her.


Und ich denke, das wird auch noch breiter werden von dem, ... ... welche Leute jetzt anwenden können.


Also wenn ich jetzt meine ...


... persönlich an meine Schwester, an meine Mutter noch denke, die noch keinen Zugang dazu richtig finden, ich versuche es immer wieder mal so ein bisschen anzubringen.


Da ist so, meine Schwester arbeitet im medizinischen Bereich, meine Mama arbeitet im Pflegebereich, also das ist noch so, ... ... ist für die noch weit weg, also sind nicht so die Techniker vor dem Herrn.


Aber ich denke auch da wird es Einzug halten, gerade mit Hausarztrobotern oder wenn man an die Pflege denkt, ... ... so Hebel, irgendwie Stützroboter, die dann irgendwann mal unterstützen können bei der Pflege.


Wobei natürlich im medizinischen Bereich ist glaube ich so, das ist ja schon immer so die Speerspitze von KI auch irgendwie medizinische Diagnostik, Bildanalyse.


Das war immer schon ganz groß, ja ist ja schon da.


Also gerne mal die KI-Folge aus der ersten Staffel anhören, da gibt es genug Beispiele.


Gut, dann springen wir doch mal in unser Thema für heute.


Bodo, du hast ein Interview geführt.


Jetzt habe ich mir nicht nochmal rausgeschrieben, mit wem und worüber, das überlasse ich jetzt dir, das entsprechend anzumoderieren.


Ja, genau.


Das Interview war mit Professor Pfeiffer von der Hochschule in Coburg.


Der Professor Pfeiffer, der ist, glaube ich, seit knapp 20 Jahren


Professor an der Hochschule in Coburg, jetzt eben für Softwareentwicklung, hat da eben zwei Spezialgebiete, sage ich mal.


Und ich kenne ihn schon sehr lang, weil wir hatten mit ihm Kontakt über einen ehemaligen Studenten von ihm, der bei uns angefangen hat, schon vor über zehn Jahren, und hatten damals schon ein paar Sachen zusammen gemacht.


Und jetzt ist eben im Zuge des Podcasts die Idee entstanden,


Auch weil ich einfach ein paar Fragen hatte, wo ich dachte, Mensch, das möchte ich eigentlich schon.


Wollte ich schon immer mal einem Hochschulprofessor fragen.


Und es wird sich doch eigentlich gut für so eine Podcast-Folge eignen.


Und genau das habe ich dann gemacht.


Na ja, und vor allem waren wir in der letzten Folge ja das Thema ganz stark auf Berufsschule.


Und was lernt man da so?


Und was kann man danach?


Und jetzt weiten wir damit quasi die Frage aus.


Hat das perfekt gepasst.


Wir machen das jetzt so, ich saß nämlich bei dem Interview nebendran und habe versucht zu verstehen, worum es geht und es ist mir nicht an jeder Stelle gelungen.


Von daher habe ich das jetzt mal in ein paar Stücke zerschnitten und wir hören uns das jetzt peu à peu an und dann reden wir vielleicht tatsächlich noch mal kurz über den einen oder anderen Punkt.


So würde ich das jetzt einfach mal machen.


Da bin ich jetzt schon gespannt.


Ja, dann begrüße ich Sie noch mal recht herzlich zu unserem Podcast, Professor Pfeiffer.


Vielen Dank, dass Sie Zeit gefunden haben, für uns Rede und Antwort zu stehen.


Gerne.


Und als erstes würde ich sagen, stellen Sie sich doch mal kurz vor.


Ja, mein Name ist Volkhard Pfeiffer.


Ich bin jetzt seit über 20 Jahren Informatikprofessor an der Hochschule Groburg.


Bin dort eingebettet in die Fakultät Elektrotechnik und Informatik und mein Spezialgebiet, sowohl was die Lehre angeht, auch was meine industrielle Erfahrung angeht, liegt im Bereich der Softwareentwicklung.


Und ein Kollege und ich, wir vertreten in diesem Informatikstudiengang eben wesentliche Teile des Fachgebiets Softwareentwicklung.


Ja, als Einstiegsfrage dachte ich, wäre es eine ganz gute Idee, vielleicht mal für unsere Zuhörer, für diejenigen unserer Zuhörer, die vielleicht auch gerade vor der Berufsentscheidung erst noch stehen oder vor der Studienentscheidung noch stehen, mal kurz zu erläutern, was ist denn eigentlich das Berufsfeld des Informatikers?


Was umfasst denn das eigentlich?


Ja, das Berufsfeld des Informatikers ist sehr vielfältig.


Das wissen Sie ja auch aus eigener industrieller Erfahrung.


Könnten Sie vielleicht gleich auch noch ein paar Sätze vielleicht von Ihrer Firma berichten?


Es ist sehr vielfältig in der Hinsicht, dass Sie in vielen Branchen an der Produktentwicklung mitarbeiten können.


Sie können zum Beispiel bei Medizingeräten mitarbeiten, bei der Entwicklung von Medizingeräten.


Sie können bei der Entwicklung von Steuerungen in ICE-Zügen mitarbeiten, also überall dort, wo


die Software, die Informatik einen wesentlichen Teil des Produkts darstellt.


Das ist der Bereich Softwareentwicklung in allen Branchen.


Auf der anderen Seite gibt es innerhalb der Firmen sehr viele Rechenzentren, IT-Zentren genannt, mit der Zielsetzung, die Firmenabläufe innerhalb der Firma


als auch die Abläufe zwischen den Firmen zu digitalisieren.


Insofern haben wir da ein Consulting-Bereich, ein Prozessfeld, wo die IT eine zentrale Rolle spielt.


Das gilt übrigens nicht nur für die Industrie, sondern das gilt natürlich auch für die öffentliche Verwaltung.


Wir stehen ja gerade in Deutschland an manchen Ecken noch bezüglich der Digitalisierung noch nicht so gut da.


Da gibt es viel noch Nachholbedarf in einzelnen Branchen,


bei öffentlichen Kommunen, sodass sie ein sehr breites Spektrum haben, wo sie als Informatiker tätig sein würden.


Ganz nebenbei ist die Nachfrage nach Informatikern extrem hoch und das zahlt sich dann auch in den entsprechenden Gehaltszusagen aus.


In aller Kürze.


Ja, den letzten Satz kann ich auf jeden Fall unterschreiben.


Also wir suchen natürlich auch händeringend sozusagen nach ausgebildeten Informatikern oder bilden zum Teil sogar selber aus, wie wir in der letzten Folge unseres Podcasts auch schon gehört haben.


Aber man könnte ja, Sie haben das ja gerade schon sehr umfassend erläutert, wo Informatiker überall arbeiten können, aber man könnte ja fast schon fragen,


Im Sinne jetzt auch der allgemeinen Digitalisierung unseres gesamten Lebens, gibt es überhaupt noch ein Berufsfeld, in dem ein Informatiker nicht arbeitet?


Genau.


Ja, richtig.


Also es ist ja eigentlich wirklich fast jedes, jeder Bereich heutzutage hat irgendwas mit Computer, mit IT zu tun.


Und das ist natürlich, es sind Bereiche, wo Software eine Rolle spielt, die erst mal das ermöglichen muss.


Und da ist natürlich, sind die Informatiker gefragt.


Richtig, genau.


Ja, stimmt.


Ja, das ist wohl wahr.


Ja, eines der Fächer, die Sie unterrichten, ist Softwarearchitekturen und Testen, glaube ich, so heißt der Titel.


Richtig, ja.


Das ist ein Fach im Bachelorstudiengang, richtig?


Das ist ein Fach im Bachelorstudiengang.


Wir unterscheiden ja in solchen Studiengängen zwischen Pflicht- und Wahlpflichtfächern.


Wahlpflichtfächern können die Studierenden selber sich aussuchen, also selber sich im Prinzip ihr Portfolio zusammenstellen.


Und das ist jetzt ein Wahlpflichtfach.


Obwohl ich dazu sagen muss, obwohl die Inhalte im Grunde genommen ja Grundlagen sind, die sie auf jeden Fall benötigen, wenn sie in der Softwareentwicklung tätig sein wollen und möchten.


Aber ich sage mal, wenn ich mir vorstelle, ich hätte jetzt noch nie was von Informatik gehört und dann kommt quasi diese Wortkombination Software und Architektur.


Ich glaube, das versteht man nicht von vornherein, aber das hat jetzt wahrscheinlich nichts damit zu tun.


Also ich frage jetzt, ich stelle mich mal ein bisschen dumm.


Das hat jetzt wahrscheinlich nichts damit zu tun, die Grundlagen von Programmierung an sich zu lernen.


Das ist schon was, was darauf aufbaut, oder?


Das ist das, was darauf aufbaut.


Wir versuchen oder ich versuche dann eben zu Beginn mal so die Analogie zwischen den klassischen jahrhundertealten Ingenieursdisziplinen eines Hausbaus, die Analogien zur Softwareentwicklung darzustellen.


Das heißt, wie baut man komplexe Systeme?


Und wenn Sie mal die ganzen Software Systeme, die überall zum Beispiel auch in Automobilen oder in Steuerungen oder Prozesse beschreiben, verbaut sind,


dann haben die mittlerweile eine Komplexität und da gilt es einfach, diese Prinzipien, grundlegende Prinzipien, die sie dafür benötigen, zu erlernen, zu üben und in einem größeren Kontext anzuwenden.


Aber ich sag mal, wenn ich mir so vorstelle, als Student an der Hochschule, wenn ich jetzt da, sagen wir mal, ich habe jetzt meinen Grundlagenkurs Programmierung hinter mich gebracht und ich habe so die ersten paar Programmchen geschrieben, die dann vielleicht hundert oder vielleicht mal tausend Zeilen lang sind, aber das sind ja noch relativ übersichtliche Projekte, die sich relativ einfach noch gedanklich erfassen lassen.


Wie begründen Sie denn den Studenten, dass man überhaupt sowas wie Architektur einer Software überhaupt benötigt?


Naja, vielleicht darf ich noch eine Sache vorweg sagen.


Diese Vorlesung Software-Architekturen und Testen baut sich eine ganze Reihe von Vorlesungen ein, ist also sozusagen nur ein Puzzle im Gesamtsystem, um ein komplexes Software-System zu entwickeln.


Und wir versuchen den gesamten Lebenszyklus, den gesamten Entwicklungslebenszyklus, den man als Wissen benötigt, um ein Softwareprodukt zu entwickeln, abzubilden.


Und häufig ist es ja so, dass mit Informatik gleich Programmieren verbunden wird.


Das ist aber eben nicht so.


Ja, wenn man Informatiker wird, dann muss man viele andere Techniken auch erlernen.


Dazu gehören einerseits Dinge, die jetzt nicht im Rahmen dieser Vorlesung, im Rahmen einer anderen Vorlesung gelesen werden, nämlich Anforderungen.


Wie formuliere ich konkret Anforderungen?


Wie modelliere ich diese Anforderungen konkret?


Und wie kann ich denn, und da sind wir dann wieder bei dem Thema Softwarearchitekturen und Testen, wie kann ich die dann in Lösungen, in Architekturen umsetzen?


Welche Technologien benötige ich?


Wie ist das Zusammenspiel dieser Technologien?


Wie zerlegen sich Systeme?


Das sind alles so Beispielfragen, die man benötigt, um solche komplexen Software-Systeme zu entwickeln und zu entwerfen.


Weil Sie jetzt gesagt haben, es gibt noch einen anderen Kurs, in dem Anforderungen oder das Stellen von Anforderungen unterrichtet wird.


Ist das aus Ihrer Sicht sozusagen, gehört es auch im engeren Sinn zur


zum Berufsfeld des Informatikers dazu?


Oder ist das, oder sieht man das eher, sehen Sie das eher in einem Umfeld von einem Wirtschaftsinformatiker, was ja auch ein Studienzweig ist, jetzt nicht an Ihrer Hochschule, aber prinzipiell gibt es das ja auch.


Ist das, wie sehen Sie da die Abgrenzung?


Also das Fach, was wir ergänzen, was wir zusätzlich anbieten, nennt sich Software Modellierung und Anforderungsmanagement.


Und das ist zunächst einmal ein ganz, ja, das ist ein ganz allgemeines Fach, was Sie sowohl benötigen, also das Know-how benötigen, wenn Sie sich wirklich um die Softwareentwicklung im engeren Sinne kümmern,


Sie benötigen aber auch das Wissen, wenn sie zum Beispiel Prozessabläufe, Firmenabläufe mal sich klar machen müssen und diese entsprechend modellieren müssen.


Insbesondere spielt bei dem Thema Softwaremodellierung und manchmal nennt man das auch Requirement Engineering auf Englisch auch gerade der Umgang mit Kunden eine zentrale Rolle.


Und zum zweiten spielen dort auch Prozessmodelle eine Rolle.


Das heißt, welche Abläufe, welche Tätigkeiten, welche Rollen gibt es denn überhaupt so in Softwareprojekten im ganzen Allgemeinen?


Und das ist eine Frage, die bezieht sich sowohl auf die Wirtschaftsinformatik-Fachrichtung wie auch auf die Kerninformatik.


Welche Rollen oder welche Prozessmodelle sind denn in Ihrer Vorlesung Software- oder ist das überhaupt in Ihrer Vorlesung Softwarearchitektur ein Thema, sozusagen diese Prozessmodelle, die es da gibt?


Nein, die Prozessmodelle sind zunächst einmal ein Thema in diesem Fach Softwaremodellierung und Architektur.


Und gleichzeitig haben wir auch noch ein Grundlagen, das ist ein Pflichtfach, das nennt sich Grundlagen Software Engineering.


Also da geht es eher um die Grundlagen, um Standardmodellierungstechniken, um diese Prozessmodelle.


Und wenn man diese Prozessmodelle aber mal reflektiert, dann merkt man sehr schnell, um die dann wirklich mal zu erlernen und zu üben, muss man größere Projekte und Aufgaben durchführen.


Und dazu sind diese Vorlesungen, über die wir jetzt gerade gesprochen haben, eigentlich vom Umfang her noch zu klein.


Und deshalb schließt diese gesamte Vorlesungsreihe mit einem Fach, was dort heißt Softwareprojekt,


Und in diesem Softwareprojekt werden die ganzen Techniken sowohl von der Kundenseite, von den Prozessmodellen, wie auch von den Architekturen anhand einer komplexen Aufgabe im Rahmen eines Semesters gelöst.


Das ist sozusagen das Zusammenspiel, das Ende dieser Softwareentwicklungsreihe, die dann anhand einer komplexen Aufgabenstellung mit einem echten Kunden, externen Kunden in Anführungsstrichen, dann erarbeitet wird.


So, da gehen wir dann gleich jetzt nochmal genauer drauf ein, aber ich habe vorher das Bedürfnis, das nochmal so ein bisschen in einfacheren Worten zusammenzufassen.


Also ihr erklärt da zwar einiges schon auch an Fachbegriffen, aber ich hätte das gerne nochmal etwas auf den Punkt.


Erzählt mir mal, was ist eine Softwarearchitektur?


Was macht man, wenn man Software modelliert?


Und was sind Prozessmodelle in dem Zusammenhang?


Naja, erst mal kann man sich fragen, was ist denn ein Modell an sich?


im Kontext Softwareentwicklung ein Modell oder allgemein ist ein Modell immer eine Vereinfachung der Wirklichkeit.


Genauso wie ein Modell eines Hauses eben von Weitem, wenn man es richtig von der richtigen Seite mit dem richtigen Licht fotografiert, tatsächlich so aussehen kann wie das echte Haus, aber es ist eben trotzdem nur ein Modell.


Und genauso mit dem Modell kann man aber schon bestimmte Dinge tun.


In der Architektur kann man z.B.


anhand einem Modell Verhältnisse, Größenverhältnisse sehen.


Also man kann z.B.


ein Foto davon machen, als es noch keine Computer gab.


Da hat man ein Modell gebaut, hat dann irgendwie ein Männchen davor gestellt und dann hat man gesehen, aha, wie sieht denn das Haus, wie sieht denn die Fassade im Verhältnis zu einer Person aus?


Und ein bisschen so ähnlich ist es in der Softwarearchitektur oder in der Softwarebranche insgesamt.


Man versucht, von der Wirklichkeit ein Modell zu definieren, was die wesentlichen Eigenschaften dessen, mit denen man arbeiten will, sozusagen beschreibt, mit denen man dann bestimmte Aktionen machen kann.


Beispiel.


Ich habe ein Modell einer Motorsteuerung.


Und da muss ich natürlich jetzt wissen, okay, der Motor


Die Software kennt ja nicht den Motor selber, die kennt nur bestimmte Parameter.


Also der Motor hat eine Drehzahl, der hat eine Verdichtungsmessung vielleicht und das sozusagen speise ich in das Modell ein.


Das heißt, das Modell besteht eigentlich dann letzten Endes nur noch aus dem Parameter,


Motordrehzahl, also aktuelle Drehzahl plus meinetwegen Verdichtungsverhältnis aktuelles oder Mischverhältnis zwischen Luft und Benzin oder sowas.


Und in der Software sind sozusagen dann nur noch diese Parameter, die bilden dann das eigentliche Modell.


Und aufgrund von diesem Modell kann man bestimmte Berechnungen machen.


Jetzt kann man zum Beispiel sagen, aha, wenn der Motor aktuell diese Drehzahl und dieses Mischungsverhältnis hat, dann


muss ich irgendwas anderes tun, weil das ist schlecht für den Motor.


Dann muss ich die Benzineinspritzung erhöhen oder erniedrigen oder sonst irgendwas.


Aber das Modell selber sind eigentlich bestimmte Parameter, die ich aus der Wirklichkeit in dem Fall gemessen habe.


Oder das geht genauso im Verwaltungsbereich.


Ich habe das Modell eines Vertrags, eines Versicherungsvertrags.


Und der hat auch bestimmte Parameter.


Und aufgrund dieser Parameter


kann man dann bestimmte Entscheidungen treffen, was weiß ich, ob der Kunde jetzt dann im nächsten Jahr mehr zahlen muss oder nicht.


Und das ist jetzt quasi die Software-Modellierung, die du beschreibst?


Naja, das ist quasi halt, vielleicht kann man es einfach so sagen, ein Software-Modell ist letzten Endes die Zusammenfassung aller für die weitere Programmierung der Software relevanten Parameter.


Das ist ein wichtiger Punkt übrigens, die relevanten Parameter, also nicht schon irgendwie Vordenken und irgendwie


Was könnte denn nochmal übermorgen für Anforderungen kommen?


Also nicht overengineeren sozusagen, sondern halt wirklich das, was man gerade braucht, das wird im Modell gezeigt.


Aber da ist für mich jetzt schon mal ein Groschen gefallen.


Ich hätte den Begriff nämlich spontan irgendwie anders eingeordnet, aber es geht darum, die Realität so zu vereinfachen, dass ich ein Programm dafür schreiben kann.


Also Realität hätte ja wahrscheinlich unendlich Parameter, da kann ich irgendwie Luftfeuchte, Dichte und alles Mögliche, aber ich versuche da das so zu abstrahieren, dass ich einen Motor, sagen wir mal, auf die zehn wichtigsten Parameter runterbreche, damit ich dann


Software schreiben kann, die mit diesen Parametern arbeitet.


Beziehungsweise die für den Use-Case benötigten Parameter, die er dann braucht.


Genau.


Und das ist eigentlich der richtige Stichpunkt.


Use-Case.


Eigentlich kommt man sozusagen von der anderen Seite her, wenn man sowas modelliert, in Anführungszeichen.


Also das ist das, was der Professor Pfeiffer hat, der das Wort mehrmals benutzt, die Modellierung.


Ich schaue mir nämlich zuerst die Anforderungen an.


Was will ich denn überhaupt erreichen?


Was ist denn mein Problem, was ich lösen will?


Und dann überlege ich mir, was ist die minimale Anzahl der Parameter, die ich definieren muss, die ich erfassen muss, um das machen zu können.


Weil ich möchte ja mit möglichst wenig Parametern arbeiten.


Kann man das immer so von vornherein schon?


Naja, das ist halt auch ein Prozess und eine Arbeit, die eben dann zum Beispiel ein Requirements Engineer tatsächlich auch macht, die natürlich auch Aufwand bedeutet.


Ich muss wirklich das Problem genau verstehen, muss die Einzelteile verstehen, muss auch als Requirements Engineer dann üblicherweise mit verschiedenen Parteien sprechen, weil der Requirements Engineer ist ja Fach


Mann für Requirements Engineering und nicht Fachmann in, was weiß ich, Versicherungsfragen.


Das heißt, der muss dann tatsächlich zu irgendeinem Versicherungsfachexperten gehen und muss dann sagen, ich will jetzt dein Problem oder was ist dein Problem und welche Parameter habe ich und wie kann ich das quasi erst mal zu Fuß mit Papier und Bleistift lösen und wenn ich das verstanden habe, wie das geht,


Dann kann ich auch beschreiben, wie man es in der Software machen kann.


Okay, also da gehen wir glaube ich später noch ein wenig drauf ein.


Da geht es dann später im Interview auch noch drum, um was man in so einem Fall vielleicht auch macht.


Dann vielleicht mal noch den Begriff Softwarearchitektur.


Ja, Softwarearchitektur.


Das Problem, sag ich mal, bei Software schreiben an sich ist, dass Software sehr komplex sein kann.


Und üblicherweise ist es so, dass der einzelne Softwareentwickler schon nach wenigen Monaten, sag ich mal, sein eigenes Programm eigentlich nicht mehr überblickt.


Das ist wirklich ein Problem.


Kommt das zwangsläufig zu diesem Punkt?


Kommt früher oder später, ist man an diesem Punkt.


Da gebe ich recht.


Das heißt, am Ende, wenn man mit mehreren Leuten über mehrere Monate oder gar Jahre hinweg eine Software entwickelt, dann gibt es niemanden mehr, der alles überblickt.


Es gibt niemanden mehr, der genau weiß, was mit wem zusammenhängt und wie wo was geändert werden müsste, um zum Beispiel eine neue Anforderung zu implementieren.


Und damit sich die Softwareentwickler so einigermaßen überhaupt eine Chance haben, sozusagen dieses Problem dann zu lösen, also die Software zum Beispiel zu erweitern oder zu ändern,


versucht man, die Software so zu strukturieren, dass es irgendwie gedanklich einfache Bausteinchen gibt, so wie bei Lego.


Man muss auch nicht genau verstehen, mit wie vielen Mikrometern genau die Toleranzen von so einem Lego-Baustein sind, sondern ich weiß einfach, wenn ich zwei Lego-Bausteine sehe, dann weiß ich sofort, wie ich die zusammensetzen kann.


Das passt auch nur an einer Stelle, das passt auch nicht umgekehrt und rückwärts und wenn man sie verdreht, sondern das passt nur genau an einer Stelle.


Und so ähnlich ist es bei Software, denke ich auch.


Man versucht möglichst die Software in so einfache Bausteine aufzuteilen, die möglichst von außen eine einheitliche, also wir Softwareentwickler nennen das dann Schnittstelle haben.


Also letzten Endes der


Die Form eines Lego-Bausteins gibt ja vor, wie man sie auf andere Lego-Bausteine sozusagen zusammenstecken kann.


Und genau so eigentlich ist die Idee bei Softwarearchitektur auch, dass man solche Bausteine schafft, die man irgendwie so Lego-mäßig quasi zusammensetzen kann, aber auch im Zweifel wieder auseinandernehmen kann und irgendwie anders oder was dazwischen reinstecken kann.


Und das ist eigentlich die Softwarearchitektur, dass man versucht, diese Bausteine, diese Interfaces, wie wir sagen, oder Schnittstellen zu definieren,


dass sie möglichst unabhängig voneinander sind beispielsweise, dass man sie möglichst leicht verstehen kann, dass man sie aus einer High-Level-Sicht auch irgendwie verstehen kann, ohne dass man jede einzelne Zeile sich wieder anschauen muss, um zu verstehen, was das Programm, also was dieser Programm teilmacht.


Ist das dann ein eigenes Berufsbild oder ist das was, was so, das klingt ein bisschen so wie, okay, da sitzen jetzt 100 Entwickler an einem Tisch und tanken sich und machen untereinander aus, was jetzt irgendwie wohin übergeben werden muss.


Oder gibt es da einen, wie ein Dirigent, der das orchestriert?


Aus meiner Sicht muss das jeder Softwareentwickler eigentlich können.


Ich wollte gerade einhaken und sagen, dass die meisten Architekten früher mal Softwareentwicklungen gemacht haben, also die, die sich DTC-Architekten nennen.


Es gibt halt in Firmen tatsächlich immer wieder welche, man beginnt immer wieder der Rolle des Softwarearchitektens, die aber aus der Entwicklung kommen und manchmal auch noch in der Entwicklung drinhängen und viel Code kennen, auch noch von früher, die auch von dem Projekt


früher mal die entwicklerrolle hatten jetzt die architektenrolle eingenommen haben hilft in sehr komplexen projekten hilft tatsächlich da eine dedizierte rolle zu haben der noch die der die die flughöhe auch einnehmen kann diese andere flughöhe und sagen kann also du hast ja high level gesagt.


Ich hab mal so die Adlerflughöhe von meinem Mentor damals gelernt bekommen, nimm doch mal die Adlerflughöhe ein und beschreib deine Software und das ist hilfreich, mal so ein bisschen Schritt zurück zu gehen und eben so auf die großen Teile zu gucken, die sollen in der Software eigentlich dann funktionieren müssen miteinander.


Die einfachste Trennung wäre jetzt sowas wie, was bei uns oft vorkommt, halt Frontend und Backend.


Das ist die simpelste Trennung, die wir vornehmen, so als Gynäkosoft einer der höchsten Flughöhen.


Aber das ist ein guter Stichpunkt, weil du sagst Softwarearchitekt.


Also es gibt natürlich tatsächlich den Begriff oder auch das Berufsbild des Softwarearchitekten, wie du schon richtig gesagt hast.


Aber ich würde sagen, Softwarearchitektur geht eigentlich jeden Softwareentwickler an, weil man hat eben, wie du auch schon richtig gesagt hast, es gibt ja verschiedene Ebenen.


Und insofern stimmt sozusagen dieses Bild mit den Lego-Bausteinen, was ich vorhin gebracht habe, natürlich nicht ganz, weil bei Lego-Bausteinen gibt es quasi nur eine Ebene.


Aber in der Softwareentwicklung gibt es ganz viele verschiedene Hierarchien, auf denen man diese Blöcke sozusagen baut.


Das ist fast so ein bisschen, kennt ihr Fraktale?


Wisst ihr noch dieses Apfelmännchen?


Ja.


Da kann man immer weiter reinzoomen und man sieht immer wieder neue Details.


Und fast so ein bisschen kommt es mir bei Softwareentwicklung auch vor.


Wenn ich so von außen als Anwender drauf schaue, dann sehe ich nur die Benutzeroberfläche und irgendwie sehe ich aber nicht, was dahinter steckt.


Und dann schaue ich da ein bisschen weiter rein.


Und dann kann ich sozusagen weitere Blöcke finden oder sehen, oder sollte sie sehen, die dann eben auf einer tieferen Ebene wieder so eine Blockstruktur, so eine Architektur bilden.


Und insofern gibt es eben einen Softwarearchitekten, der quasi auf der obersten Ebene die Zusammenarbeit zwischen Teams zum Beispiel, zwischen verschiedenen Server-Systemen zum Beispiel,


regelt und bestimmt, so Dinge wie Sicherheit auch.


Und dann gibt es aber eben auf der ganz untersten Ebene, also wo ich meine einzelnen Codezeilen schreibe und die Ebene, die knapp darüber ist, also eine Methode oder eine Funktion, die aus zehn Codezeilen besteht, das ist ja auch schon ein Baustein.


Und auf der Ebene


arbeitet normalerweise der Softwarearchitekt nicht, sondern das ist eben aus meiner Sicht die Verantwortung von Softwareentwicklern, auf dieser eher unteren Ebene sich sehr wohl sehr viel Gedanken über die Softwarearchitektur zu machen von dem, was sie gerade entwickeln.


Okay, dann noch eine letzte Frage, bevor wir dann den nächsten Abschnitt machen.


Das klingt so, als wäre es ein fortlaufender Prozess und nicht so, weil der Begriff Architektur ist man ja schnell bei der Analogie Hausbau.


Da ist ja das Modell von vornherein fest und wird eigentlich auch nicht mehr angefasst.


Genau.


Das wird natürlich, dieses Bild mit dem Hausbau, das wird natürlich gerne verwendet, weil es natürlich auch vom Sprachlichen her passt, aber das bricht natürlich relativ schnell in der Softwareentwicklung.


Ist Softwarearchitektur nichts, was man einmal festlegt und dann immer so ist, sondern im Gegenteil, das ist definitiv was, was immer im Fluss ist.


Die Anforderungen ändern sich und dann muss sich oft auch die Softwarearchitektur ändern und zwar manchmal auch sehr radikal ändern.


Okay, also und das ist was, das kann man lernen offensichtlich an der Hochschule.


Und ich fand diese Idee mit diesem Abschlussprojekt, da habt ihr dann auch noch ausführlicher drüber geredet, das fand ich eigentlich ganz schön.


Und da geht es jetzt auch im zweiten Abschnitt so ein bisschen um die Rollen, die man dann in so einem Testprojekt, aber dann natürlich auch im späteren Berufsleben so einnehmen kann.


Und das heißt dann, dass sozusagen diese anderen Vorlesungen, wie zum Beispiel auch eben Software-Architekturen und Testen, die sind dann Voraussetzung, um dieses Software-Projekt dann belegen zu können.


Richtig.


Das ist dann eine Voraussetzung, um dieses Software-Projekt belegen zu können.


Genau.


Und da werden dann speziell auch nochmal, auch das ist ja auch nochmal immer eine wichtige Sache in solchen Software-Projekten, Gruppen von Studierenden gebildet, von fünf bis sieben Studierenden.


die unter einer Leitung eines Masterstudierenden dann arbeiten.


Und wir als Hochschulprofessoren coachen diese Teams dann.


Ah, okay.


Da würde ich gleich noch mal gern drauf zurückkommen, weil das interessiert mich auch sehr.


Aber ich würde gern erst noch mal das Thema Softwarearchitektur noch mal abschließen, vorläufig zumindest.


Wie schaut denn, also wenn wir jetzt noch mal bei Softwarearchitektur in dem Sinne bleiben,


Sie haben ja schon erklärt, dass es eben eine Notwendigkeit ist, um Software zu strukturieren, weil Software groß und komplex ist und so weiter.


Aber wie stelle ich mir denn jetzt da so eine typische Prüfungssituation eigentlich vor?


Weil, Sie haben ja selber schon gesagt, dass man kann natürlich in einem Umfang von so einer Vorlösung nur eine begrenzte Komplexität überhaupt machen, allein von der Anzahl der Stunden, die man hat.


So, wie bringe ich jetzt so ein Thema, was eigentlich nur bei komplexen Softwareprojekten überhaupt eine Rolle spielt, wie bringe ich denn, wie presse ich das jetzt sozusagen in so einen Unterricht und dann auch letzten Endes in so eine Prüfung rein?


Wie geht denn das eigentlich?


Das ist, denke ich, ein bisschen auch die Schwierigkeit dieser Vorlesung.


Die setzt sich, oder die Prüfung besser gesagt, setzt sich ja aus so kleineren Puzzleteilen zusammen.


Das muss man sich so vorstellen, manche Dinge, die beziehen sich, obwohl das in der Informatik ja gar nicht so häufig vorkommt, einfach auf Begriffswelt.


Da muss man manche Begriffe verstanden haben und auch mal erklären können.


Also beispielsweise, was verstehen wir denn überhaupt unter einer Softwarearchitektur?


Um da ein Beispiel zu machen.


Also das sind einerseits Dinge, die sich auf grundlegende Begriffe beziehen.


Andererseits gibt es bei solchen Entwurfsaufgaben ganz spezielle Techniken, Entwurfsmuster, Design Patterns, auch im Englischen genannt.


Und da geht es darum, diese Design Patterns, die wir in dem Rahmen auch in dieser Vorlesung geübt haben, auf bestimmte Problemstellungen korrekt anzuwenden.


Dann gibt es einen dritten Teil, der bezieht sich jetzt auf das Thema Testen.


Testen ist auch so ein Gebiet, wo man einfach wichtige Begriffe einfach erst mal wissen und erklären muss.


Also was versteht man zum Beispiel unter einem Systemtest?


Oder was ist zum Beispiel ein Unitest?


Und auf der anderen Seite werden diese Prüfungen dann so stattfinden, dass die Studierenden für vorgegebene Programme, Codeteile tatsächlich systematisch Testfälle entwickeln müssen.


nach den Systematiken, die dann in der Vorlesung behandelt worden sind.


Also insofern ist das jetzt ein Mix aus verschiedenen Teilen, was die Prüfung angeht.


Okay.


Ja, dann kommen wir nochmal zurück auf das, auf das andere Thema, wo Sie vorhin gesagt haben.


Also das, das andere Fach, in dem die Studenten dann gruppenweise an so einem Softwareprojekt arbeiten.


Ja.


Was sind denn, was, was, Sie haben auch den Begriff Prozessmodelle irgendwie genannt.


Also was ist denn eigentlich so ein Softwareprozessmodell für unsere Hörer?


Also die Grundlagen der Prozessmodelle, die klassischen, also die sogenannten planbaren Prozesse wie auch die agilen Prozesse, die werden ja in unserem Pflichtfach Grundlagen Software Engineering gelehrt.


Und hier geht es jetzt tatsächlich in diesem Software Projekt darum, anhand einer Aufgabenstellung, also machen wir mal ein Beispiel.


Wir hatten zum Beispiel eine Verwaltungssoftware erstellen lassen, eine webbasierte Verwaltungssoftware zum Erstellen von Prüfungsplänen.


Studierende müssen ja Prüfungen dann jedes Semester bearbeiten und haben, Prüfungen und da muss ein Plan erstellt werden und der ist aufgrund seiner vielzältigen Abhängigkeiten sehr komplex.


Also es ging darum, so eine Software zu erstellen und wenn die Gruppen dann gebildet werden und eine solche Aufgabenstellung bekommen, dann ist zunächst mal die erste Aufgabe, den


Typischerweise den Software-Entwicklungsprozess auszuwählen.


Ich sage mal zu 99,9 Prozent wählen die Studierenden.


Wir lassen ihnen da zunächst mal Freiräume, agile Prozesse aus.


Typischerweise ein Scrum-Prozess und dieser Scrum-Prozess wird dann getailert, angepasst an die Bedürfnisse dieser Aufgabenstellung.


Das heißt, die Teams und auch die Master Studierenden, die ein wenig die Prozess, vor allen Dingen die Prozesssicht, das Anpassen des Software Entwicklungsprozesses an diese Aufgabe haben, die passen die typischerweise Scrum Prozesse an die Aufgabe entsprechend an.


Ist das dann für die Masterstudenten auch quasi ein Lernprojekt in dem Sinne?


Oder machen die das eher so nebenbei?


Nein, das machen die nicht nebenbei.


Die müssen aus ihrer Sicht eben auch ein sogenanntes Masterprojekt belegen.


Das heißt, die bekommen auch aufgrund ihrer Mastertätigkeit, ihres Masterstudiums dieses Faches eine Note auf diese Tätigkeit und coachen eben die Bachelorstudierenden.


Ah, das ist ja interessant.


Die weiter Fortgeschrittenen bringen den noch nicht so weit Fortgeschrittenen sozusagen was bei.


Ja, so ist die Idee.


Also das funktioniert natürlich immer manchmal besser, manchmal schlechter.


Wir als Professoren coachen diese Teams.


Und da kommen natürlich auch nicht technische Aspekte eben, spielen da auch eine ganz wichtige Rolle.


Wir haben sehr viel in den letzten, naja, ich möchte schon sagen fast Jahrzehnten, waren wir, ein Kollege und ich, in Didaktikprojekten und haben auch eine Pädagogin hier an Bord.


Und das heißt, wir schauen auch an, wie die Teams intern funktionieren, sodass die Studierenden eben aus Fehlern lernen und auch lernen, die sämtliche Softskills, die sie so brauchen, Zusammenarbeit,


Probleme zu lösen etc.


Alles, was so in üblichen Softwareprojekten dann auch an Menschlichkeit anfällt, dass dort solche Erfahrungen in den Projekten mitgenommen werden und dass sie daraus lernen aus den Fehlern, die sie machen.


Ja, ich habe gelesen, Sie hatten ja auch eine, vor einigen Jahren eine Forschungsveröffentlichung zu dem Thema gemacht.


Ja.


Ich glaube, die heißt Learning and Teaching Software Process Models.


Ja, richtig.


Und da beschreiben Sie ja so ein bisschen auch die Herausforderungen von der didaktischen Seite.


Richtig, ja.


Die es, die es da gibt.


Können Sie das noch so ein bisschen erläutern, was war gerade am vielleicht


am Anfang ihrer Professorenkarriere, was da so die Herausforderung war, das irgendwie so zu strukturieren, dass es dann irgendwie auch funktioniert.


Naja, da steckt schon eine große Herausforderung in der Vergangenheit da drin.


Zunächst mal war das so, dass wir Professoren eher so als Kunden aufgetreten sind in solchen Teams.


So haben wir mal gestartet.


Und dann haben wir aber gemerkt, das ist aber nicht adäquat, weil A sprechen die Studierenden mit uns Professoren und wir sind ja in der Hinsicht zumindest aus Studierendensicht nicht unabhängig.


Und B lernen sie zum Beispiel auch nicht mal mit externen Kunden zu kommunizieren.


Also das war schon mal die erste Sache, die wir geändert haben.


Das heißt, in solchen Projekten gibt es immer externe Kunden, die die Anforderungen definieren für diese Sachen.


Beispielsweise für die Prüfungsplanungssoftware sind es dann ein Kollege oder eine Mitarbeiterin, die sich nur um die Prüfungsplanung kümmert.


In dem Sinne eine Kundin dieser Software.


Dann haben wir festgestellt, als zweiten Lerneffekt, dass die Studierenden natürlich auch selber lernen müssen, Dinge anzupassen.


Also das heißt, wir wollten jetzt, wir Professoren wollten jetzt nicht mehr die Rolle desjenigen einnehmen, der sozusagen alles vorgibt, sondern die Studierenden müssen am Ende ihres Informatikstudiums natürlich in der Lage sein, Softwareprozessmodelle gemäß der Anwendung, die sie zu entwickeln haben, selber anzupassen und auszusuchen.


Und das hat uns dann zu diesem finalen Konzept, möchte ich schon fast sagen, geführt, dass wir sagen, wir stellen so eine Gruppe von Bachelorstudierenden zusammen plus Masterand oder Masterandinnen, die dann die Bachelorgruppe aussteuert.


Das hat sich in den vielen Jahren sehr bewährt.


Und gleichzeitig bieten wir dann auch noch, begleitet durch unsere Pädagogin, eine Art Softskill-Training und Coaching an, wo wir dann die Gruppen beobachtet haben und dann auch im Nachgang mit der Gruppe besprechen, welche menschlichen Sachen, welche Softwareprojektsachen zum Beispiel nicht ganz so gut gelaufen sind.


Und daraus lernen die Studierenden und die Evaluation, die Bewertung von den Studierendengruppen zeigen uns, dass sich das Konzept eigentlich sehr bewährt hat.


Es ist sehr beliebt, dieses Softwareprojekt, obwohl es einen hohen Arbeitsaufwand für die Studierenden bedeutet.


Das heißt, Sie haben dann auch systematisch Studierende, die das sozusagen abgeschlossen haben, dann befragt?


Richtig, wir werden, wir werden, wir machen immer eine Art, ja, wir nennen das, es klingt jetzt schlimm, Post-Mortem-Sitzung, wie das ja teilweise auch Sie vielleicht in Firmenhand haben oder in abgeänderter Form handhaben, wo wir dann jetzt weniger um die ganzen Ergebnisse, die die Studierendengruppen uns abgeliefert haben, die werden ja separat benotet von uns, sondern wir machen dann eine Sondersitzung nach Projektende,


und diskutieren dann mit den Teams, was eigentlich gut und was schlecht gelaufen ist.


Alles mit der Zielsetzung, dass Studierende aus diesen Team- und Projektaufgaben und Projektrollen, die sie innehatten, lernen für die Zukunft, für die Industrie.


Hier bei uns dürfen sie sich Fehler erlauben, das ist ganz normal und sie sollen aus diesen Fehlern lernen.


Das heißt, wir würden das bei uns wahrscheinlich Retrospektive nennen, ist das das?


Ja, die Retrospektiven, die haben die Studierenden selber auch.


Die finden teilweise sogar in wöchentlichen Runden statt.


Das organisieren die Studierenden dann wöchentlich untereinander.


Und diese Postmortem-Sitzung kommt dann sozusagen am Ende des Projekts nochmal mit uns als Professoren dazu.


Weil wir bei diesen retrospektiven Sitzungen nicht immer anwesend sind.


Ganz bewusst nicht, weil die Studierenden dann untereinander erstmal ihre Sachen klären sollen.


Manchmal dabei sind dann erzeugte, manchmal Zwänge und das ist dann eben nicht gerade gut zum Erlernen der Teamstruktur.


Für die nächste Frage setze ich jetzt mal wieder den Hut des Selbersoftwareentwicklers auf und wir arbeiten ja auch mit Scrum natürlich.


Wie kann man sich das dann vorstellen in so einer Studentengruppe?


Also wer ist denn da der Scrum Master zum Beispiel?


Ja, das ist der Masterrand.


Also der Masterstudent oder der Masterstudierende.


Deren Aufgabe ist es, den Prozess erstens am Anfang des Projekts mit dem Team festzulegen und dann die Verbesserungsmaßnahmen beziehungsweise die Kontrolle im gesamten Projekt zu übernehmen.


Das ist speziell die Aufgabe dieses Masterstudierenden.


Ja, verstehe.


Und dann gibt es ja noch die Rolle des Product Owners wahrscheinlich, oder?


Ja, also wenn wir diese verschiedenen Rollen wie Product Owner, Softwarearchitektur, Testmanager all betrachten, dann legen die Bachelor Teams das zunächst mal untereinander fest.


Wir machen da keine Vorgabe als Professoren, sondern das gehört eben auch zur Eigenständigkeit dazu, erst mal sich nochmal über die Rollen im Clan zu werden und die im Team selbstständig festzulegen.


Das heißt, die haben das ja dann in der vorherigen Vorlesung sozusagen theoretisch gelernt, was sind überhaupt diese ganzen Rollen, was bedeuten die und so weiter.


Und wenn sie dann in dem eigentlichen Projekt sind, dann müssen sie sich untereinander verständigen, wer jetzt welche Rolle einnimmt.


Richtig.


Ist ja auch logisch, dass der Master Rand dann den Scrum Master macht und die anderen sind dann die Scrum Bachelor.


Wahrscheinlich.


Ja.


Die lernenden Programmierer.


Naja, ich meine, der Masterand sollte vielleicht ein bisschen mehr offensichtlich Informationen darüber haben, wie dieses Prozessmodell, also dieses Entwicklungsprozessmodell überhaupt aussehen muss, wie das, was das für Komponenten sozusagen hat, also welche


regelmäßigen Treffen es zum Beispiel gibt, zu welchen Themen und wer mit wem spricht oder wer mit wem nicht spricht und all diese Dinge.


Und von daher macht es wahrscheinlich Sinn, wenn das ein Masterrant macht, weil der das hat vielleicht schon zweimal, dreimal gemacht in anderen Zusammenhängen.


Oder natürlich eine Masterrantin.


Das war mir gar nicht so klar, glaube ich.


Brauchst du für die Rolle des Scrum Masters dann auch so einen Hardcore-Entwicklungs-Background?


Oder ich meine, dass ich da auch schon viele gesehen hätte, die aus ganz anderen Richtungen kommen.


Nein, das ist eigentlich ganz unterschiedlich.


Also ich zum Beispiel in meinem Team habe aktuell einen Scrum Master, der tatsächlich auch mit einem Software-Entwicklungs-Hintergrund kommt, der das aber schon viele Jahre nicht mehr macht, Software-Entwicklung.


Aber wir haben auch bei uns im Unternehmen eine Scrum Masterin, die kommt zum Beispiel eigentlich aus dem Human Resources Bereich.


Die war mal bei uns.


Ganz früher hat die als Personalfachkraft angefangen und hat sich dann in Richtung Scrum Master weiterentwickelt.


Also ist ganz verschieden.


Und die kommt aus dem Psychologieumfeld.


Das finde ich eher noch interessant, weil das tatsächlich Scrum Masterschaft hat, meine ich, viel mit Umgang mit Personen zu tun, auch mit Psychologie, Kenntnissen vielleicht zu tun.


Ist es dann vielleicht sogar eher hinderlich, wenn man zu viel Entwicklungshintergrund hat?


Kann sein, weil dann ...


Gibt es vielleicht Scrum Master, die würden gerne eine andere Rolle einnehmen und dann, das habe ich auch schon mal erlebt, ja, aber hinderlich ist es nicht.


Also es ist gut so von allem so ein bisschen Verständnis mitzubringen.


Ich würde eher im Gegenteil sagen, dass man einen kleinen Vorteil hat als Scrum Master, wenn man auch ein bisschen versteht, worüber die Entwickler gerade sprechen.


Weil der Scrum Master ist ja eigentlich so eine Art Moderator.


Er ist auf der einen Seite so eine Art Moderator für die verschiedenen Besprechungen, die es innerhalb dem Team oder sogar auch mit dem Kunden gibt.


Und auf der anderen Seite ist es auch jemand, der sozusagen


darauf achtet, dass all diese Besprechungen zeitnah auch entsprechend stattfinden oder sogar sehr regelmäßig stattfinden.


Weil Entwickler, also mir geht es jedenfalls so auch,


Man ist oft sehr fokussiert auf das Problem, auf das aktuelle fachliche Problem, was man lösen soll und dann kommt irgendjemand daher und sagt, ah, wir müssen uns jetzt mal zusammensetzen und müssen mal drüber reden, was die letzten zwei Wochen gut oder schlecht gelaufen ist.


Aus Entwicklersicht ist das erstmal lästig, sowas.


Das heißt, als Entwickler ... Würde ich 1 zu 1 auch in anderen Bereichen so wahrscheinlich sehen?


Ich würde das jetzt erstmal nicht von mir aus anstoßen.


Deswegen ist es gut, einen Scrum Master zu haben, der sagt so, an genau dem Tag machen wir genau das und nichts anderes.


Also hat so ein bisschen die Aufsichtspflicht.


Ja, gewisserweise schon, ja.


Ja, und es geht ja auch darum, dass der Scrum Master auch die Meetings, die stattfinden, dann effizient hält.


Genau.


Und da hilft dann gerade der technische Background, wenn der merkt, die Diskussion trifft sich jetzt gerade ab oder dreht sich im Kreis oder irgend so was, dass dann der Scrum Master auch in einer Art unterbrechenden Rolle da sein sollte und sagt, die Diskussion gehört jetzt hier gerade nicht her oder die lagern wir nochmal in ein anderes Meeting aus oder irgendwas.


Ich meine, das heißt jetzt nicht, dass nicht Leute, die jetzt quasi fachfremd sind in dem Sinne, also keinen Softwareentwicklungshintergrund haben, dass die schlechte Chrome hast.


Das sind es, glaube ich, überhaupt nicht.


Da gibt es schon auch sehr gute Leute.


Man hat halt vielleicht dann nicht so das tiefe Verständnis, wenn Softwareentwickler über technische Details sprechen.


Ich denke, da muss man dann halt auch wahrscheinlich an der Stelle noch mehr die Leute lesen können.


Also ich könnte mir sogar vorstellen, dass es manchmal hinderlich ist, wenn du durch Fachlicht zu sehr mitdenkst, weil du dich dann gar nicht auf die andere Ebene so konzentrierst.


Okay, es geht jetzt auch im weiteren Gespräch geht es noch um beliebte Rollen.


Da kommen jetzt noch ein, zwei andere Rollen mit dazu.


Hören wir uns das auch mal noch an.


Gibt es da Rollen, die besonders beliebt oder besonders unbeliebt bei den Studenten sind?


Also, das ist gar nicht so ganz einfach zu beantworten, die Frage.


Was aber immer ein Aha-Effekt ist, weil ich mache dieses Projekt ja nicht erst seit zwei Jahren, sondern über viele, viele Jahre begleite ich dieses Software Projekt bereits, ist das Thema Testen.


Das Thema Testen wird immer unterschätzt vom Aufwand her und klingt am Anfang auch nicht so ganz attraktiv, da eine entsprechende Testmanager-Rolle zu übernehmen.


Aber die Meinung und die Sichtweisen, das ist eben auch ein sehr schöner Lerneffekt.


Die ändern sich doch am Ende des Projekts sehr, sehr häufig signifikant.


Ich hatte gerade im letzten Wintersemester auch eine Studierende, die sagt also Testmanagerin, da will sie zukünftig in der Industrie arbeiten.


Das hat ihr sehr gut gefallen.


Also man sieht, man hat bestimmte Vorurteile zu Beginn, aber die revidiert man doch, wenn man das Projekt mal durchgeführt hat.


Und sonst ist natürlich klar, sonst versuchen, und das ist ja auch sinnvoll, versuchen die Studierenden natürlich die Rollen auszuwählen, wo sie glauben, auch ihre Stärken zu haben.


Nicht jeder ist sozusagen gerade im technischen Umfeld der gute und beste Softwarearchitekt.


Also der eine oder andere zum Beispiel dem liegenden Kundengespräch mehr, der geht mehr in die Anforderungsecke.


Ich denke, das ist zunächst mal ein ganz normaler und typischer Interessenauswahl bei der Bestimmung der Rollen.


Ja, kann ich mir vorstellen, ja.


Ja, das ist ja schön, dass die Studenten dann sozusagen da auch dann, sag ich mal so, Vorurteile dann abbauen, indem sie selber erfahren, wie das eigentlich funktioniert, ja.


Ja.


Klingt, klingt wirklich spannend, ja.


Weil sie gesagt haben, Testen ist ja auch so ein Thema, was ich prinzipiell so ganz interessant in meinem Berufsalltag finde.


Deswegen frage ich jetzt da mal ein bisschen spezieller.


Also es gibt ja verschiedene Teststrategien und so weiter und es gibt irgendwie


automatische Tests im weitesten Sinne.


Dann gibt es Unit-Tests, Integrations-Tests, die automatisch sind.


Aber es gibt ja auch so dieses Test-Driven-Development, diesen Begriff.


Ist das was, was bei Ihnen auch in der Lehre sozusagen eine Rolle spielt?


Dieser Test-Driven-Development-Ansatz, bei dem man ja eigentlich die Tests noch schreibt, also die automatischen Tests noch schreibt, bevor man die eigentliche Software sozusagen entwickelt?


Ja, ist gerade in meiner Vorlesung Software Architektur und Testen auch ein Übungsteil.


Ich habe ein ein Minipraktikum und bei diesem Minipraktikum treten zwei Gruppen, zwei Personen gegeneinander an.


Also das heißt, da sind vier Personen beteiligt, in einer Gruppe jeweils zwei Studierende.


Und da geht es genau darum, dass die eine Gruppe den Test der anderen schreibt.


Das heißt, die eine gibt Tests vor, die eine gibt die Schnittstelle vor und die anderen müssen den Test dazu schreiben.


Das ist genau der Test Me Driven First Ansatz.


Erst den Test schreiben und dann den Code.


Den führen wir eben als Praktikum in meiner Vorlesung Software-Architekturen und Testen durch.


Und dann ist es den Teams im Software-Projekt selbst überlassen, ob sie diesen Test-Driven-First-Ansatz tatsächlich in dem größeren Kontext anwenden oder nicht.


Gibt es dann Gruppen, die es machen?


Ja, es gibt die eine oder andere Gruppe, die es macht.


Meistens wird der Ansatz doch nicht gewählt.


Aber interessanterweise ist natürlich folgendes.


Man sieht natürlich sehr schnell, dass dieser Ansatz nur dann funktioniert, wenn die Schnittstellen, ich könnte mal genauer gesagt werden, auch wenn die Methoden, wenn die


Wenn die Komponenten wirklich fest definiert sind, dann funktioniert dieser Ansatz hervorragend.


Wenn natürlich die eine Gruppe ihre Schnittstelle ständig ändert und die zweite Gruppe muss dann ihre Tests nachziehen, weil die Schnittstellen sich geändert haben, dann funktioniert dieser Ansatz nicht mehr.


Und das merken die Studierenden natürlich auch, dass zu diesem Ansatz eine gewisse Disziplin dazugehört und auch eine gewisse Stabilität der Architektur.


Sonst führt das einfach zu mehr Aufwand an der Stelle.


Das kann ich mir vorstellen, ja.


Wir stellen das bei uns ja auch fest in den Projekten, also bei uns im Haus und auch in Projekten, die wir für Kunden machen.


Haben jetzt gerade in letzter Zeit das Thema Test Driven Development so in Gesprächskreisen bei uns in der Firma.


wieder mehr thematisiert und auch natürlich, man unterhält sich mit Kollegen so oder mit anderen Teams, macht ihr das, wie macht ihr das und so weiter und stellt mir fest, naja, es gibt nicht, es ist noch, ich würde mal sagen, es ist auf jeden Fall noch nicht die Mehrheit, auch der erfahrenen Softwareentwickler, die das wirklich machen.


Obwohl, meiner Meinung nach, das eigentlich ein sehr,


Eigentlich der bessere Ansatz ist, Software zu entwickeln, würde ich sagen.


Also für mich und auch in den Projekten, in denen ich das sozusagen konkret praktisch ausprobiert habe.


Ich halte es für sehr vorteilhaft, aber ich merke auch, dass es eine relativ hohe, einerseits steile Lernkurve hat


Vor allem aber merkt man auch für Softwareentwickler, die das einfach nicht gewohnt sind, die tun sich schon zum Teil sehr hart, sich einfach umzugewöhnen.


Einfach diese andere Denkweise.


Zuerst eben, wie Sie schon sagen, zuerst die Schnittstellen zu definieren, zuerst das Konzept zu machen, ohne dass man konkret die Software schon schreibt und dann den Test für das Konzept zu machen und dann erst die Software zu schreiben.


Genau, ja.


Es ist nicht ganz einfach, ja.


Nein, es ist nicht ganz einfach und setzt im Prinzip auch ein Detail-Level voraus.


Ja, ich denke, auf der einen Seite ist es so, dass es natürlich hilft, wenn man in dem Umfeld, in dem man sich bewegt, also mit der Programmiersprache und mit den Frameworks, die man arbeitet, wenn man da eine gewisse gute Vorerfahrung mitbringt, dann tut man sich natürlich schon mal leichter, bestimmte Dinge quasi zu konzipieren, ohne dass man sie gleich umsetzt.


Weil manchmal, wenn man das eben nicht, wenn man nicht in dieser Situation ist, dass man die Programmiersprache und das Framework schon gut kann, dann ist man oft zu explorativ unterwegs und probiert Dinge aus.


Und das ist mit Tests, macht das nicht unbedingt einfacher.


Wobei ich behaupte, auch das geht.


Aber jetzt frage ich mich eben, wie wäre es denn, wenn man sozusagen das Programmieren von vornherein so beibringt?


Also ich komme darauf, weil ich habe neulich von einem großen Verfechter von Test Driven Development ein Buch gelesen und der hat irgendwo geschrieben, er hat seiner Tochter sozusagen, bringt er auch gerade das Programmieren bei.


Er hat sozusagen an ihr den Versuch gemacht, sofort ihr quasi diesen Test-Drift im Ansatz beizubringen, noch bevor sie quasi eine Zeile programmieren konnte, hat sie erst mal gelernt, einen Test zu programmieren, sodass sie es gar nicht anders gewohnt ist.


Und ich kenne jetzt natürlich nicht die Auflösung, wie es sich sozusagen weiterentwickelt hat, aber da frage ich mich eben, wäre das nicht auch ein Ansatz in der Lehre, sozusagen von vornherein zu sagen, hey, wir machen wirklich zuerst die Tests, weil es sich als das bessere Konzept


entwickelt hat und weil es nicht unbedingt sinnvoll ist, es erst andersrum zu lernen, um sich dann doch wieder umzulernen.


Also die Frage ist glaube ich nicht so ganz einfach zu beantworten, weil die Schwierigkeit bei den Anfängervorlesungen bezogen auf die Programmierung ganz im Allgemeinen ist zunächst mal die Heterogenität an Vorkenntnissen.


Das heißt, die Studierenden bringen ganz verschiedene Vorkenntnisse mit.


Manche haben zum Beispiel in Schulen durchaus Kenntnisse erworben.


Manche sind Fachinformatiker.


Und das führt jetzt zum Beispiel dazu, dass wenn dort Übungen bearbeitet werden, die mit Vorkenntnissen von zwei Übungsblättern fertig sind und weiter sind als die anderen.


Und wenn ich auf Ihre Frage jetzt Test Me First zurückkomme, dann glaube ich, gibt es auch in der Form Unterschiede, dass die ohne Vorkenntnisse, die tun sich zunächst mal besonders schwer, überhaupt mal so einen Test programmieren zu können.


Wenn das Basiswissen nicht, zumindest bis zu einem gewissen Sockel da ist.


Die andere Gruppe mit Vorkenntnissen, die tun sich da wesentlich leichter.


Was ich aber in dem Kontext jetzt mache, das ist jetzt eher eine didaktische Frage, die aber auch darauf Einfluss hat, ist, ich biete jetzt erstmalig seit letztem Wintersemester diese Programmiersprachenvorlesung, die Prüfung dieser Vorlesung Programmierung digital an.


Das klingt, als wenn das nichts mit Ihrer Frage zu tun hat, aber das läuft im Rahmen mit unserem E-Learning System.


Das nennt sich Moodle und dort gibt es ein sogenanntes Plug-In und das heißt Code Runner.


Und dieser Code Runner ist in der Lage, einen zum Beispiel Java Code oder C++ Code auszuführen.


Und ich hinterlege in diesem Code Runner Testfälle für den Code.


Das heißt, die Studierenden erarbeiten ihre Lösung und sehen aufgrund der Testfälle, die von mir hinterlegt sind, sofort, welche Testfälle erfolgreich sind und welche viel geschlagen haben.


Das ist natürlich nicht der Test Me Driven First Ansatz, weil die Testfälle zunächst mal von mir hinterlegt worden sind.


Das ist vielleicht eine Vorstufe, wenn Sie so wollen.


Aber zumindest werden auch die Anfänger schon mal bereits mit Testen sensibilisiert.


Was ich wichtig finde.


Könnte man das nicht genau umdrehen?


Das heißt, Sie liefern sozusagen gleich die Implementierung mit und verlangen dann die Tests dazu und eine entsprechende Testabdeckung oder sowas?


Ja, das könnte man schon auch mal versuchen.


Aber wie gesagt, ich glaube, wenn ich die Schwierigkeiten sehe, es gibt viele Studierende,


Die sitzen vor einfachsten Aufgaben und wissen nicht, wie sie die lösen sollen.


Und für diese Zielgruppe, und da haben wir durchaus eine ganze Reihe, denke ich mal, die werden vermutlich überfordert.


Für die andere Gruppe wäre das durchaus ein sehr interessanter Teil.


Ja, also das ist aber die Schwierigkeit.


Ich muss natürlich allen Gruppen gerecht werden und alle Gruppen über die Prüfungshürden bringen, sodass man das sehr genau überlegen muss.


Aber es ist sicherlich ein wichtiger Punkt.


Also Software testen ist ein wichtiger Punkt.


Ganz klar.


Genau.


Ja, ich meine, Sie sind natürlich vermutlich nicht in der Situation, sozusagen Studierende aussieben zu wollen absichtlich.


Also ich meine, die Softwareentwickler sind ja, wie wir am Anfang schon gehört haben, sind ja wirklich gesucht, nicht nur in Deutschland, sondern weltweit.


Gibt es eigentlich zu wenig Softwareentwickler.


Das heißt, man will ja eigentlich wirklich jeden mitnehmen.


Was ist denn eigentlich, was sind denn eigentlich die, aus Ihrer Sicht, die Voraussetzungen, die eigentlich jemand mindestens mitbringen muss, wenn er sowas studieren will?


Das ist eine sehr gute Frage.


Die Frage kann man ja durchaus auch fast auf die Informatik als Ganzes auswählen.


Was muss ich eigentlich mitbringen?


Jetzt haben wir natürlich zweieinhalb Jahre Corona-Semester hinter uns und diese Corona-Semester haben auch unsere Studierenden schon beeinflusst und verändert.


Und wenn ich solche Informationsveranstaltungen für Schüler durchführe und ich gefragt werde, was muss denn ein Schüler mitbringen, damit er ein erfolgreiches Studium absolviert, dann ist meine Antwort zunächst einmal Motivation, überhaupt Neues zu lernen.


Und das ist jetzt weniger eine Frage, die sich jetzt auf die Kenntnisse der Schule bezieht, sondern es ist eher aus der Erfahrung geboren, dass viele, viele Studierende aus verschiedensten Gründen einfach


wenig Disziplin haben, wenig Motivation haben.


Und das zeigt sich zum Beispiel daran, dass in solchen Fächern wie Programmieren und anderen Fächern dann eine Woche vor Prüfungs, vor Prüfungsdurchführung erstmal der Stoff erlernt wird.


Und da scheitern sie.


Also wesentlicher Teil, und das sage ich auch allen, ist einfach Motivation mitbringen.


Das klingt jetzt auf den ersten Blick natürlich als Grundvoraussetzung, aber leider gibt es doch eine ganze Reihe von Schülern, Absolventen von Schulen oder von anderen Bildungseinrichtungen, die zu uns kommen, die diese Motivation nicht mehr mitbringen oder nicht so mitbringen in dem Umfang.


Und auch die Disziplin, die sie brauchen, wöchentlich Dinge nachzuarbeiten, teilweise auch ziemlich hinten anstellen.


Also insofern, das ist ein wesentlicher Punkt.


Natürlich, wenn man auf die fachlichen Voraussetzungen eingeht, ist es natürlich sehr gut, wenn man gewisse mathematische Fähigkeiten mitbringt.


Aber auch da erzählen mir alle Mathematikkollegen, wenn man die vielen Jahre jetzt mal überblickt, die die Mathematikkollegen unterrichten, nehmen die Mathematikvorkenntnisse ab, sodass wir also vieles auch durchführen, auch hier an unserer Hochschule in Coburg im Informatikstudiengang.


Mathematik, Kenntnisse aus der Schule, Vorkenntnisse zu wiederholen, zu üben, zum Beispiel durch Vorkenntnisse und auch während des Studiums, während der ersten Semester werden die Studierenden sehr stark begleitet.


Aber der zentrale, wichtigste Punkt für mich ist einfach mal Motivation mitbringen und den Biss haben und den Biss haben, auch wenn das ein oder andere Fach mal nicht so ganz gut funktioniert, sich durch das Studium durchzubeißen.


Das ist eine wesentliche Voraussetzung für den Erfolg eines Informatikstudiums.


Jetzt stelle ich mal eine ganz provokante These auf, weil Sie gerade gesagt haben, ja, mathematische Vorkenntnisse, es wären auch wichtig.


Das ist ja so das Ding, was ich eigentlich auch, als ich angefangen habe, mir einen Beruf auszusuchen, ich habe jetzt allerdings nicht Informatik, sondern ich habe Elektrotechnik eigentlich studiert ursprünglich,


Auch gedacht habe, ja, Mathematik ist irgendwie so ein großes Ding, das ist irgendwie wichtig, so als Grundlagen.


Und bei mir im Elektroingenieurstudium war das auch tatsächlich so.


Also wir haben auch doch einiges an Mathematik auch lernen müssen, was irgendwie deutlich über das hinausging, was man an der Schule gelernt hat.


Wenn ich jetzt aber, und ich habe dann aber nach meinem Studium ziemlich direkt sozusagen in die Softwarebranche gewechselt, habe da zunächst eine Software programmiert, die tatsächlich auch mit Mathematik im weitesten Sinne zu tun hat, nämlich Signalverarbeitung.


Das ist auch ein quasi, ja, sehr mathematisches Feld.


Aber dann bin ich in einen Bereich gekommen, dann, und die letzten, ist es auch die letzten 20 Jahre, kann man sagen, bin ich in dem Bereich, wo ich sagen muss, naja, wenn ich jetzt mal genau überlege, wie viel Mathematik brauche ich eigentlich für die Software, für vor allem so Unternehmenssoftware,


mit der ich zu tun habe, da muss ich sagen, ja, also plus minus mal geteilt und das war's dann schon.


Mehr Mathematik brauche ich eigentlich fast nicht, ja.


Ich brauche noch so ein paar so Überlegungen, was ist ein Set und so, quasi so mengenleere Sachen irgendwie so ein bisschen.


Ja, viel mehr ist es dann auch nicht.


Und deswegen, das hat mich in letzter Zeit so ein bisschen zur Überlegung gebracht, naja, was ist denn eigentlich Software schreiben, Software entwickeln, wenn man so mal sich betrachtet.


Auch die Dinge, Anforderungsmanagement, über das wir vorher gesprochen haben, solche Dinge oder eben auch diese ganzen sozialen Aspekte.


Ist es nicht vielleicht tatsächlich eher so, dass Softwareentwicklung auch einen ganz starken Sprachaspekt hat?


Also, dass das vielleicht gar nicht so mathematisch ist oder nicht sein muss.


In manchen Bereichen wahrscheinlich schon, aber nicht in allen Bereichen.


Und dass es mehr vielleicht auch so ein sprachliches, konzeptuelles Thema ist.


Also, wo jetzt jemand, der vielleicht mit Mathematik gar nicht so viel am Hut hat, durchaus auch Erfolg haben könnte.


Also, vielleicht eines vorweg.


Ich möchte jetzt ...


auch potenziellen Interessenten, Schülerinteressenten oder Studienanfängerinteressenten auch ein bisschen die Angst vor der Mathematik nehmen.


Man schafft die Mathematik in dem Informatikstudium.


Wie gesagt, wenn man dieses Ding motiviert und lernbereit wiederholt.


Aber jetzt zur eigentlichen Frage.


Ich denke, die Frage muss man differenziert sehen.


Eine Kerneigenschaft eines Informatikers am Ende seines Informatikstudiums ist die Fähigkeit zu abstrahieren.


Also unwesentliche Dinge von wesentlichen Dingen zu trennen.


Und dieses zieht sich durch ganz, ganz viele Bereiche, insbesondere natürlich auch gerade im Software Entwicklungsbereich, im Software Architekturbereich, aber eben auch im Anforderungsbereich.


Man muss Dinge einfach abstrahieren können.


Und dazu ist die Mathematik eine wesentliche Hilfestellung.


Man lernt dort zu abstrahieren.


Das ist also insofern, wenn man so will, eine Unterstützung, diese Abstraktionsfähigkeit zu lernen.


Und eine zweite Sache, jetzt gibt es natürlich mittlerweile diverse Spezialgebiete.


wo wirklich Mathematik Kenntnisse zwingend erforderlich sind.


Ich nenne mal nur zwei Beispiele.


Das eine Wir haben einen zusätzlichen neuen Informatik Studiengang bei uns, der nennt sich Visual Computing.


Da geht es um Computer Grafik und Bild Verarbeitung.


Und wenn Sie in der Medizintechnik zum Beispiel in einem MR Scanner ein 3D Bild eines eines Kopfes aufgenommen haben, wo der Arzt durch diesen Kopf navigiert,


Dann passieren dort mathematische Transformationen.


Das heißt, da brauchen Sie diverse Mathematikkenntnisse.


Das ist ein Beispiel.


Ein zweites Beispiel, was in aller Munde ist, ist KI.


Das heißt, wir brauchen dort diverse Mathematikkenntnisse, zum Beispiel auch Stochastikkenntnisse, um Algorithmen entwickeln zu können in dem Fachgebiet KI.


Also insofern muss man die Mathe da sehr differenziert sehen und man muss selbstverständlich auch abgrenzen.


Das haben wir getan.


Welche Mathematikinhalte brauchen Informatiker wirklich nicht und welche halten wir für die Grundausbildung für zwingend erforderlich?


Da muss man abwägen, das ist klar.


Aber mit der gleichen Argumentation müsste ich ja dann vielleicht auch hergehen und sagen, naja gut, wenn ich jetzt Software im Medizinbereich schreibe, dann brauche ich auch eine Grundbildung in Sachen Medizin oder medizinische Bildgebung.


Naja, ich meine, diese fachliche Expertise, die musst du dir natürlich dann irgendwie draufschaffen.


Also wenn du eben im Medizintechnikbereich Software schreibst, glaube ich schon, dass du dir als Softwareentwickler auch den bestimmten fachlichen Aspekt, ist eigentlich für jeden Softwareentwickler so, der muss sich die Software, die er entwickelt, die fachlichen Aspekte, muss er schon auch verstehen.


Und das muss er dann vielleicht auch im Zweifel lernen.


Das ist schon so.


Ja, kenne ich eigentlich aus meinem Alltag als Werbetexter auch nicht anders.


So, wenn ich Broschüren über Medizingeräte schreibe oder das Beste, was ich mal hatte, war ein U-Boot.


So, dann bin ich auch erstmal lange damit beschäftigt, mich da einzulesen.


Wobei dann auch die Frage ist, inwieweit einem das ... ... von einem zum Beispiel Product Owner ... ... runtergebrochen wird auf ... ... kleinere Problemstellungen.


Also von einem Fachlehrer, der halt dann sagt, ... ... er hat so diesen riesen Fachkontext und sowas, ... ... den muss man vielleicht nicht komplett kennen ... ... als eigentlicher Umsetzer, Entwickler dann.


Genau, aber halt den Ausschnitt, ... ... für den du sozusagen die Lösung entwickelt.


Genau, den Ausschnitt für die Lösung, ... ... den sollte man dann sehr genau kennen ... ... und sehr gut kennen ... ... und wo man sich da vielleicht einordnet ... ... im Gesamtkontext auf einer anderen Flughöhe vielleicht.


Ja, wahrscheinlich kann man es manchmal auch tatsächlich ohne großes Domänenwissen irgendwie auch lösen, wenn man irgendwie Anomalien in medizinischen Daten sucht.


Vielleicht lassen die sich auch so aufspüren, aber ich glaube schon, dass es auch durchaus wichtig ist, da gewisse Fachkenntnisse mitzubringen.


Was ich interessant finde, also gesamt an dem Ganzen, ich bin ja nicht Akademiker, also ich bin mittlere Reife und bin dann an die


Ich habe ja dann die Ausbildung durchlaufen zum Fachinformatiker.


Ich finde ganz interessant, dass es doch relativ praxisnah mir erscheint.


Also der Unibetrieb hier, zumindest an der Universität hier Coburg, was jetzt der Professor hier beschreibt, ist sehr praxisnah.


Also an der heutigen, wie man so im Berufsalltag tatsächlich dann auch mit dem Entwickeln umgeht, mit der Softwareentwicklung umgeht.


Finde ich gut.


Finde ich erstaunlich gut.


Wenn man so hört, es brechen so viele Leute ab, weil das eben alles so praxisfern ist.


Und weil halt so diese Mathematikfilter am Anfang gesetzt werden ein bisschen, klar.


Da rasseln manche dann in die Mathematikwand rein.


Kann ich genauso unterschreiben.


So war es vor 20 Jahren, als ich mal zwei Semester Informatik studiert habe.


Da war knallhart.


Die erste Prüfung war Mathematik.


Und das hat schon ordentlich die Spreu vom Weizen getrennt.


Und alles andere, was da so außenrum war, war sehr


Trocken.


Sehr, sehr trocken.


Das war bei meinem Studium auch so.


Ich habe bei Elektrotechnik studiert, wie gesagt, und die ersten vier Semester, die waren schon sehr, auch für mich, quälend, obwohl es mich, ich meine, ich habe es halt dann durchgezogen, weil es mich, weil ich keine andere Idee hatte, was ich sonst hätte machen können, sagen wir mal so.


Aber ich war dann wirklich, als ich das Grundstudium hinter mir hatte, mit eben diesen Grundlagenfächern, irgendwie Physik, Chemie und vor allem natürlich Mathe, eine ganze Menge.


Und dann gab es noch diese Systemtheorie, was auch sehr mathematisch war.


Das Hauptstudium dagegen war wirklich dann irgendwie, fühlte sich dann als Spaziergang an, weil da waren dann wirklich die interessanten Sachen drin, weswegen ich das eigentlich studiert habe.


Diese ersten vier Semester, die waren nicht so.


Aber denkt ihr, das hat sich gewandelt oder denkt ihr,


steile Überhang ist immer noch da, oder?


Lasst uns da gleich nochmal kurz dann drüber reden.


In die Richtung kommen dann jetzt auch noch Fragen.


Ich würde nochmal ganz kurz zurückrudern, weil der nächste Abschnitt sich auch schon nochmal auf die Frage Modellwissen, Domainwissen und so weiter darum dreht.


Und dann können wir gerne dann danach nochmal zurückkommen auf, wie hält man das denn aktuell überhaupt und so.


Ich möchte noch mal auf ein anderes Thema kommen, was Sie, glaube ich, auch unterrichten, nämlich Model-Driven Development und Domain-Specific Languages.


Ja.


Das ist auch ein Gebiet, was Sie unterrichten, richtig?


Das ist richtig.


Das habe ich unterrichtet im Master.


Wir haben ja nicht nur eine Bachelor Informatik, sondern wir haben auch eine Master Informatik.


Zukünftig werden wir auch ein Master Data Mining haben, ab Wintersemester, aber das unterrichte ich in der Master Informatik.


Ja, das ist jetzt so ein Bereich, also gerade ein Model-Driven-Development ist so ein Bereich, in dem ich mich persönlich jetzt noch fast gar nicht damit beschäftigt habe.


Also ich weiß schon grob, was es ist, aber Domain-Specific-Language ist schon eher.


Aber können Sie unseren Hörern sozusagen kurz erklären, was Model-Driven-Development eigentlich ist erstmal?


Ja, da gibt es verschiedene Stufen.


Model-Driven-Development, ich sage mal so eine Kernidee ist ja, dass man ein System


ich sage es mal etwas platt, jetzt nicht ausprogrammiert, sondern dass man auf Basis bestimmter Standardmodellierungstechniken Systeme modelliert, auf einem sehr hohen Abstraktionslevel und dann versucht aus diesem Abstraktionslevel, aus diesen Modellen entsprechende Codeteile zu generieren.


Diese Forderung gibt es ja schon seit vielen, vielen Jahren.


Damals so ein bisschen begründet mit dieser Case-Welle und einer Software-Engineering-Konferenz, damals in den 60er, Ende 60er Jahre in Deutschland.


Ich denke mal, was jetzt in dem Kontext sehr interessant geworden ist, dass man in dem Kontext sich selber neue Sprachen definieren kann, die man auf einem Rechner verarbeiten kann.


Da sind wir dann eigentlich bei dem sehr engen Teilgebiet Domain-Specific Languages, also domainspezifische Sprachen.


Beispielsweise kann ich eine Sprache bauen für einen Versicherer.


Zum Beispiel haben wir in Coburg die große RUG vor der Tür, die permanent neue Versicherungstarife pro Jahr ermitteln muss, berechnen muss.


Und wenn man jetzt zum Beispiel eine Sprache definiert auf einem sehr anwendungsfreundlichen Niveau, das was der Versicherungsexperte beherrscht, dann kann man versuchen, das bezeichnet man eben auch als Model Driven Development, dann auf Basis dieser Sprache Codeteile für ein System zu erzeugen.


Kann man sich das dann so vorstellen, dass quasi der in dem Fall Versicherungsexperte, der jetzt kein Programmierer ist, dass der in der Lage ist, mit so einer domänenspezifischen Sprache quasi seine Anwendung dann doch zu schreiben?


Oder braucht er dann trotzdem noch die Unterstützung von dem Softwareentwickler?


Naja, ich denke mal, das sind zwei Teile.


Der Fachexperte, der Versicherungsexperte


bekommt eine spezifische Sprache an die Hand, die er versteht, die seine Fachdomäne, in dem Falle die Versicherungstarifierung, zum Beispiel beinhaltet.


Und er beschäftigt sich nach wie vor mit seiner Fachdomäne, also zum Beispiel mit der Berechnung von Tarifen, mit der Kalkulation von Tarifen für die verschiedenen Branchen, die es so gibt in der Versicherungswirtschaft.


Und dann gibt es einen zweiten Teil, da gibt es Entwickler, die auf dieser Basis Generatoren entwickelt haben.


Und diese Stückchen, diese Generatoren nehmen dann den Teil, den der Fachexperte geschrieben hat in seiner spezifischen Sprache und versuchen daraus Software zu generieren oder zu interpretieren.


Beides wäre möglich.


Und der Punkt ist einfach, dass man eben heutzutage


Das ist vielleicht keine neue Idee.


In der Softwareentwicklung gibt es Programmiersprachen und da braucht man einen Compiler, um ein Softwareprogramm in einen Bytecode zu übersetzen, den die Maschine versteht.


Und da versteht jeder sofort zwischen diesen beiden, zwischen der Programmiersprache und diesem Bytecode, liegt eine große Abstraktionsebene und da ist ein großer Abstraktionsunterschied.


Und diese zentrale Idee kann man eben auch mit domainspezifischen Sprachen erreichen.


Das heißt, man hat auf einem sehr hohen Abstraktionslevel spezifiziert man dann die entsprechende Fachdomäne.


und generiert tatsächlich Software-Teile eines Systems, die man früher manuell programmieren hat müssen.


Und das macht es so interessant.


Okay, und ist es dann, sozusagen bewährt sich das dann in der Praxis auch in der Hinsicht, dass der Fachexperte wirklich selbstständig sozusagen dieses Stück Programmierung, was eben in seiner domänenspezifischen Sprache ist, dass der das wirklich selber sozusagen machen kann?


Also ich frage jetzt deswegen so ein bisschen Boaz an der Stelle noch ein bisschen nach, weil ich hatte beruflich so eine ähnliche Situation.


Das könnte man wahrscheinlich auch domänenspezifische Sprache nennen, und zwar da ging es darum,


dass wir Testautomatisierung machen wollten, bei einem Projekt, das eben gemacht werden sollte.


Und dann gibt's, da gibt's ein Konzept, das nennt sich, oder das ist eigentlich auch eine Sprache, Gherkin, ich weiß nicht, ob ich Ihnen das was sage.


Ja, kenn ich.


sozusagen so Testautomatisierung beschreiben kann auf einem sehr abstrakten Niveau.


Und die Idee sozusagen war in dem Projekt, ja, man könnte doch dem PO sozusagen das an die Hand geben und der soll einfach seine Anforderungen in dieser Sprache schreiben.


Und es ist, ja, hat sich erst mal prima angehört, aber hat zumindest in diesem einen Projekt nicht so richtig gut funktioniert, weil die POs, die wollten sich dann doch nicht so oder so damit auseinandersetzen und haben dann doch vorgezogen,


ihre Anforderungen wieder irgendwie in natürlicher Sprache den Entwicklern mitzugeben und die dann sozusagen arbeiten zu lassen.


Ja, aber das ist schon die zentrale Idee zunächst einmal.


Ich meine, es ist natürlich so, die Definition einer domainspezifischen Sprache ist natürlich nicht so ganz einfach.


Das heißt, auch da muss man die Sprache so treffen, wie Sie sagten gerade, Sie haben gerade die Product Owner erwähnt.


die auch die entsprechende Zielgruppe spricht.


Beispielsweise ich habe viele Master Arbeiten zum Beispiel auch in Zusammenarbeit mit Siemens Helsing betreut, wo dann Sprache, domainspezifische Sprachen entwickelt worden sind zur Steuerung von Computertomografen.


Das sind normalerweise immer Physiker.


weil Computertomographen doch sehr spezifische physische Grundlagen haben.


Das heißt, Physiker schreiben diese Steuerungsprotokolle.


Und wenn sie dort solche domainspezifischen Sprachen dann, wenn sie die Sprache dieser Zielgruppe Physiker oder dann ihres Produktordners für Anforderungen richtig treffen,


dann schafft man es auch, dass die Sprachen benutzt werden.


Aber es ist so wie bei einem normalen Entwicklungsprozess auch, solche Sachen muss man iterieren, man muss dann Sachen verbessern, man muss Sachen refactoren, damit man wirklich diese Sprache so zielgerecht und zielgruppengerecht hinbekommt, sodass sie auch akzeptiert wird.


Das ist ein wichtiger Punkt.


Klingt jetzt aber so, als wäre es einfacher, den Physikern Programmieren beizubringen.


Ja, vielleicht.


Also mir ist das Begegnen mit dem Modellgetrieben der Softwareentwicklung tatsächlich auch schon begegnet in der Praxis.


Ich kam ja aus einem vorhergehenden Arbeitgeber aus der Automobilbranche, speziell aus der Diagnostikbranche, der Automobildiagnostik.


Und die haben für Mechatronica eine Sprache entwickelt, die letztlich es ermöglicht hat, für eine Mechatronica so einzelne Abläufe innerhalb der Software tatsächlich zu programmieren, umzusetzen.


Die wurde Syntax gecheckt, die wurde quasi kompiliert nach Java dann wieder erstmal und dann wurde natürlich Java auch wieder kompiliert in den Code, den dann die Software sprechen kann, der Computer sprechen kann.


... der Computer sprechen kann, genau.


Entschuldige.


Genau.


Jedenfalls konnten die mit so einer abstrahierten Sprache ... ... und mit ihrem OBD speziellen Sachen, ... ... also so diese ... ... Schützstellen zum Fahrzeug, ... ... die da eben dann ... ... verfügbar waren in der Sprache, ... ... konnten die so ... ... so Abläufe ... ... innerhalb unserer Software dann ... ... wirklich nicht nur definieren, ... ... sondern tatsächlich auch programmieren und umsetzen.


Und die wurden dann bei uns eingebunden ... ... und liefen dann in der Software mit ...


Und das ist so ein Bestand, eigentlich auch der Keinteil der Software besteht daraus, diese Sachen zu interpretieren und damit zu arbeiten.


Und genau, das war gerade so eine modellgetriebene Softwareentwicklung da.


Ja, das ist genau so was.


Aber weil du jetzt gefragt hast, ist es nicht effizienter, quasi den Physikern gleich das Programmieren beizubringen, das ist gar nicht mal unbedingt die Frage, weil eine domain-spezifische Sprache


die lohnt sich natürlich dann auch für jemand, der eigentlich die Software auch zu Fuß schreiben könnte, wenn das nur genügend oft gemacht werden muss.


Also wenn es genügend oft dieses ähnliche Probleme gibt, dann lohnt es sich tatsächlich, sich so eine domainspezifische Sprache zu überlegen, weil man in der einfach auch effizienter und schneller ist.


Auch als Softwareentwickler, der quasi die anderen Sprache, also die


Basissprache oder die, will man sagen, was für sich zum Beispiel Java auch könnte.


Trotzdem geht es für den dann schneller, als wenn er diese domänenspezifische Sprache zu benutzen, als wenn er das alles quasi zu Fuß machen müsste.


Ja gut, so wie man sich auch irgendwie Funktionen oder Module schreibt für wiederkehrende Aufgaben.


Genau.


Und diese domänenspezifische Sprache kann dann eben so abstrahiert auch sein, dass sich jetzt der Physiker nicht mehr darum kümmern muss, wie geht denn das Gerät an, wie fährt es hoch, wie fährt es in der Ausgangsposition oder so ein Zeug.


Das wird dann vielleicht vorher schon geschehen und sowas.


der macht dann wirklich noch den eigentlichen, was weiß ich, ich kenne mich mit medizinischen Geräten nicht aus, aber macht den eigentlichen Scan-Ablauf, programmiert jetzt der Physiker einen.


Ja, ist eigentlich, unter dem Strich, denke ich, ist es eine Frage der Effizienz.


Wenn ich viele Leute habe, die diese domainspezifische Sprache einsetzen könnten oder wenn das eben sehr häufig immer wieder vorkommt, dann macht es einfach Sinn, so eine domainspezifische Sprache zu definieren.


Glaubt ihr, wir werden so eine Entwicklung in diese Richtung beim Thema KI vielleicht auch erleben?


Haben wir ja eigentlich quasi.


Also Prompting ist, würde ich sagen, auch eine domainspezifische Sprache, um mit KI zu reden, wenn man so möchte.


Aber ich meine eigentlich, ich glaube, dass die Entwicklung dahin geht, dass die KI in der Lage ist, aus normaler, natürlicher, menschlicher Sprache,


die den entsprechenden Code zu generieren.


Also indem ich quasi die Anforderungen in menschlicher Sprache definiere, müsste die KI in der Lage sein, daraus ein Programm zu erstellen.


Ja, so jetzt auch als Endanwender vielleicht, ne?


Aber, ähm ... Moment, vielleicht ist der Gedanke auch noch nicht ausgereift.


Aber wenn ich jetzt überlege, ich mach eine KI-Anwendung als Entwickler, die ich dann wieder anderen bereitstelle, da muss ich ja schon auch ein Stück weit abstrahieren und Dinge vereinfachen.


Aber vielleicht muss ich gar nicht komplett verstehen, wie KI funktioniert.


... fertig gibt, Konzepte und Dinge aufzupfen.


Ja, es wird weg vom Prompting gehen.


Also das, was man jetzt macht momentan, ... ... wenn man mit KI spricht, muss man dann so ... ... in so gewissen Rahmen-Normen, ... ... das meinte ich eben gerade mit Prompting, ... ... mit der KI sprechen, aber ... ... das wird darauf hinauslaufen müssen eigentlich, ... ... dass man dann, wenn man ... ... Hausarzt-Roboter will ich jetzt nicht irgendwie ... ... wieder anfangen mit Hallo Alexa oder Hallo Roboter, ... ... mache mal und dann einen Ablauf und so ... ... und dann muss das wieder so genormt sein, sondern ... ... ich denke auch tatsächlich, ...


Da ist dann wieder die Frage, was dann wieder so ethisch gestellt werden muss.


Wie viel hört das Ding jetzt mit?


Wann schaltet es sich dann doch wieder ein und sagt, kann ich dir helfen, die Tasse hochzunehmen oder sowas?


Oder wo hält sich das Zeug dann wieder zurück?


Das ist dann halt Sache der zukünftigen Implementierer von solchen Geräten.


Dann kommt jetzt noch ein kurzer, aber noch ein eher komplexer Abschnitt.


Da geht es um Clean Architecture.


Und danach wird es dann auch für mich etwas einfacher und verständlicher.


Ein Thema, was mich jetzt in letzter Zeit recht beschäftigt hat.


Mal schauen, was Sie sozusagen damit anfangen können oder was Sie da auch unterrichten davon.


Also, wir waren ja ganz am Anfang auch bei dem Thema Softwarearchitekturen, was Sie ja auch unterrichten.


Und ich habe da jetzt zuletzt das Projekt, das Buch Clean Architecture von Robert C. Martin gelesen.


Das ist, glaube ich, von 2017, wenn mich nicht auftäuscht.


Ja, älteres Buch, ja.


Und da sind, ist ja sozusagen so dieses Konzept der, ich glaube, er nennt es in dem Buch noch nicht so, aber das Konzept der hexagonalen Architektur oder auch diese Onion-Zwiebel-Architektur, das geht ja auch in die Richtung, sind das auch Dinge, die Sie sozusagen in Ihrem Software-Architekturkurs schon unterrichten oder ist das noch zu fortgeschritten oder zu neu oder zu


Also ich versuche natürlich jetzt in meiner Software-Architektur- und Testen-Vorlesung zunächst mal die Grundlagen zu unterrichten.


Und da sie zweigeteilt ist, einerseits in einem Architektur- und Testteil, muss ich mich da immer beschränken.


Das heißt, auf das Thema Clean Architecture gehe ich da nicht so direkt ein.


Ich gehe auf allgemeine Entwurfskonzepte ein, die die Studierenden einfach wissen müssen.


Das sind einfach grundlegende Begriffe wie Layering, Dependency Injection,


Und ich mache übrigens auch sehr gerne Design by Contract, was jetzt eher ein Feindesign-Prinzip ist, auch zwar älter, aber finde ich nach wie vor ein sehr interessantes Konzept.


Und die weitergehenden Konzepte, die sich jetzt auch mal auf größere Architekturen beziehen, die werden dann


mehr oder minder ein bisschen je nach Gruppe oder je nach Team stärker im Software-Projekt dann angewandt, wo dann die ganzen Vorlesungen dann eben reinfließen.


Aber es ist jetzt nicht so, dass ich alle Teile von Clean Architecture oder wie Sie es bezeichnen auch die Ideen von hexagonalen Architekturen da in meinem Grundlagenfach Architektur und Testen so in Gänze behandeln kann.


Das ist aus Zeitgründen eben kaum möglich.


Ja, ja, das ist, also denke ich mir schon, das ist schon natürlich was sehr Spezielles.


Das ist ja, das Softwarearchitektur und Testen ist ja ein Bachelorfach.


Das ist ein Bachelor, genau, ist ein Bachelorfach, ja.


Wie ist es dann bei den, bei den Masterstudenten?


Gibt es dann da welche, die sich in der Richtung irgendwie spezialisieren oder die das Thema da während ihres Masterstudiums dann genauer


betrachten, vertieft lernen?


Da haben wir jetzt, wie gesagt, ich biete jetzt zu diesem Thema Model-Driven und DSL eben eine Spezialvorlesung an und da haben wir dieses Thema der Software-Architekturen im Master-Bereich nicht ganz so stark ausgeprägt.


Da haben wir andere Fächer, die durchaus auch sehr natürlich interessant sind.


Aktuell, wie gesagt, Data-Mining, IT-Security, fortgeschritten.


Da haben wir so ein Portfolio,


sodass das Architektur-Thema an der Stelle jetzt nicht so in die Tiefe geht im Master, wie es hätte auch sein müssen vielleicht oder sein muss.


Das ist eben auch an meiner personellen Ressource und an anderen Kollegen gebunden, die auch ihre Kompetenzen damit einbringen möchten.


Und ist es dann in den Fächern, die Sie jetzt im Masterstudiengang unterrichten, also wie die, die Sie jetzt zuletzt genannt haben, würden Sie dann sagen, dass jemand, der sozusagen in dem Bereich dann sein Masterstudium erfolgreich abgeschlossen hat, dass der dann in dem Sinne, wie es vielleicht auch Robert C. Martin bezeichnet hat, ein Software-Craftman schon ist, oder muss der dann im Beruf immer noch weiter lernen?


Also ich denke mal, ich bin da vielleicht etwas bescheiden.


Ich würde sagen, man muss immer im Beruf dazulernen.


Man muss immer die Fähigkeit haben, die eigentliche Aufgabenstellung im Beruf dann auf das Gelernte anzuwenden.


Also ich denke mal, da gehört immer eine Portion Erfahrung dazu.


Das sage ich auch zum Beispiel in meiner Vorlesung Softwarearchitekturen.


Design Pattern zum Beispiel, das Wissen über Entwurfsmuster,


Egal welche Art von Entwurfs, man macht noch keinen guten Softwarearchitekten aus.


Das ist eben eine Erfahrungssache und natürlich haben Masterstudierende am Ende ihres Masterstudiums einen größeren Schatz, aus dem sie hoffentlich vieles mitnehmen ins Berufsfeld, aber die Erfahrung müssen sie trotzdem weitermachen im Berufsleben und sich weiterbilden.


Das ist einfach zwingend erforderlich.


Naja gut, ich glaube das Zeitalter der Jobs, in denen man irgendwie einmal lernt und dann 20, 30 Jahre lang dann auf dem Stand bleibt, das ist glaube ich durch, egal wo man hinguckt.


Noch Ergänzungen zu dem Abschnitt?


Da muss ich sagen, das war mir dann so ein bisschen zu viel Clean Architecture.


Damit kann ich jetzt auch nichts mehr anfangen.


Ja, das ist vielleicht dann schon ein sehr spezielles Thema.


Das stimmt, ja.


Also ich denke, das ist ja wahrscheinlich in anderen Berufen auch so.


Egal wie intensiv so ein Studium ist, man kann nie alles, was man in einem Beruf später braucht, in einem Studium oder in einer Ausbildung lernen.


Ist ja bei Ärzten auch so.


Die lernen ja auch im Medizinstudium nicht alles, was sie müssen wissen.


Deswegen müssen sie ja dann irgendwie noch so und so viele Jahre in einem Krankenhaus als Assistenzarzt arbeiten, um dort die entsprechende Erfahrung unter Aufsicht eines erfahrenen Arztes dann diese Erfahrung überhaupt zu sammeln.


Und ich denke, so ähnlich ist es in der Softwareentwicklung auch.


Da gibt es hoffentlich dann


irgendwie einen Software-Architekten vielleicht in dem Team oder der für das Team, der das Team quasi berät in der Hinsicht, der dann solche Dinge einbringt.


Ja, deswegen mischt man ja auch oft in Team-Kontext jetzt nochmal einen erfahrenen Entwickler mit jüngeren Entwicklern, die so eine eher Juniorität mitbringen und noch nicht so Senior-Level sind.


Deswegen mischt man das ja auch und deswegen wendet man auch Methodiken dann an, wie Peer-Programming, dass man dann sagt, der Erfahrene geht mal mit dem Junior in eine Peer-Session rein und lernt dann von dem erfahrenen Entwickler.


Aber da steckt natürlich die Frage drin, die wir jetzt auch explizit dann noch mal die Antwort von Professor Pfeiffer hören werden, dass es schon auch eine spannende Frage ist, wie man denn auf dem aktuellen Stand der Technik bleibt.


Gerade im Kontext Schule und Ausbildung oder Universität.


Also ich meine, die Professoren, die sind nicht mehr in der Wirtschaft, die bekommen vielleicht nicht mehr jeden Trend mit, müssen aber die nächste Generation der Wirtschaft ausbilden.


Also das stelle ich mir wahnsinnig schwer vor.


Und da hast du natürlich auch reingebohrt.


Wie halten Sie sich als Unterrichtender, als Professor an der Hochschule eigentlich auf dem aktuellen Stand, so was gerade in der Softwarebranche so vor sich geht?


Also wir haben ja schon gehört, Sie arbeiten mit Unterricht und Scrum, was wahrscheinlich zu der Zeit, als Sie selber noch nicht Professor waren, wahrscheinlich auch noch nicht so ein Thema war, schätze ich mal, in den 90er Jahren.


Stimmt, ja.


Wie halten Sie sich auf dem Laufenden, dass Sie sicherstellen, dass Sie immer die wirklich relevanten und aktuellen Themen Ihren Studierenden beibringen?


Also ich denke, es liegt erstmal daran, dass sich natürlich jeder Kollege oder jede Kollegin schon auf ein spezielles Gebiet spezialisiert.


Das ist einfach, man kann nicht mehr das gesamte Spektrum abdecken.


Das ist schon mal eine Grundvoraussetzung.


Und dann hängt es natürlich ein bisschen auch von den einzelnen Fachgebieten ab.


Wir versuchen uns oder auch ich versuche mich einerseits auf Konferenzen weiterzubilden.


Das setzt manchmal natürlich auch ein gewisses Budget voraus, an solchen Konferenzen überhaupt teilzunehmen.


Da haben wir gerade auch ein bisschen stärkere Schwierigkeiten an der Stelle, aber das war in der Vergangenheit eigentlich eine gute Möglichkeit.


Und andererseits vernetzen wir uns auch aufgrund zum Beispiel dieser Konferenzen oder aufgrund von


Forschungsprojekten, die die Kollegen und die wir alle, jeder auf seine Art und Weise tätig sind.


Wir vernetzen uns dann untereinander, sodass wir uns da eigentlich gut austauschen und auch viele Dinge dann ja gemeinsam besprechen und sich weiterbilden.


Das ist natürlich bei der Geschwindigkeit, in der wir uns hier alle befinden, sicherlich keine leichte Aufgabe.


Das muss man einfach zugeben, da up to date zu bleiben.


Und das geht auch nur, wenn man sich wirklich spezialisiert und dann versucht, in dem Spezialgebiet den Studierenden die neuesten Techniken beizubringen und Technologien.


Ja, also das ist jetzt auch ein fantastischer Übergang, weil genau über die Frage habe ich auch mit dem Professor Dr.


Sigurd Schacht vom KI-Lehrstudio in Ansbach geredet.


Der ist da Studiengangsleiter für angewandte künstliche Intelligenz und digitale Transformation.


Und das ist jetzt genau das, wovon er hier redet.


Das ist nochmal eine Spezialisierung auf ein Thema, in dem wahnsinnig viel Bewegung gerade drin ist.


Also wo ich mich auch frage, wie kann man da


Wie kann man da die Rolle desjenigen einnehmen, der das den anderen beibringen muss, wenn man selber so drauf und dran ist, überhaupt mitzulernen und mitzukommen, was da gerade passiert?


Also hören wir da auch mal kurz rein.


Das habe ich auch aufgezeichnet.


Uns interessiert ganz stark auch der Weg in die Software und in die KI-Entwicklung.


Du als Hochschulprofessor, wie schaffst du es, deinen Lehrplan halbwegs aktuell zu halten, wenn sich gerade gefühlt täglich die Welt verändert, was KI-Tools angeht?


Viel lesen, das ist das Erste.


Das ist sozusagen tatsächlich das A und O, viel lesen.


Aber was natürlich, und so wie wir es jetzt hier machen, wir haben jetzt hier einen Podcast oder ein Video, was halt wahnsinnig viel hilft, ist, weil wir im Endeffekt Social Media ganz gut benutzen können.


Die ganzen wissenschaftlichen Papers zu den neuesten Entwicklungen, die werden in der Regel auf Twitter diskutiert.


Das heißt, allein bei den verschiedenen Forschungsinstitutionen als Follower zu sein, hilft einem schon, dabei zu bleiben.


Und dann muss man natürlich das übernehmen,


aufarbeiten und dann in den Lehrplan einbetten.


Das ist natürlich klar.


Was gibt es da aktuell so für Fachrichtungen, wenn ich mich in der Ecke irgendwie austoben will, wenn ich KI-Entwickler werden will?


Oh, der Sinn ist breit.


Tatsächlich, weil KI ja ein Multidomänen-Thema ist.


Das fängt also an, dass ich allein in dem Requirements-Engineering wie beim klassischen Softwareentwicklung mich betätigen kann und eruieren kann, wo bringt es einen Use-Case für die Firma.


Das wären dann eher so die, ich nenne es jetzt mal, weicheren Aspekte.


Es kann aber auch in die Richtung gehen, dass man sagt, ich möchte eher mit Sprache arbeiten, so wie es jetzt mein Forschungsgebiet ist, Sprachtechnologie, Natural Language Processing.


Aber auch die Bildverarbeitung, Computer Vision ist ein großes Thema, weil viele Sensoren in der Industrie werden durch Kameras ersetzt, weil Kameras viel billiger sind und damit natürlich die KI und die IT-Relevanz mehr steigt.


Das ist sozusagen ein Thema.


Wir haben aber auch die ganz klassischen, auch was in der KI-Feld, was oft leider


ein bisschen jetzt nach hinten gedrängt wird, weil diese großen neuronalen Netze ein großes Thema sind.


Wir haben natürlich einfaches Machine Learning, wo es um die Anomalie-Detection geht, also die Erkennung von Fehlerfällen, von Aspekten in Zahlungsströmen oder Ähnliches, wo man sich tummeln kann.


Wenn das so vielfältig ist, habe ich schon eine Vermutung, wie du die nächste Frage beantwortest.


Aber was für Voraussetzungen muss ich als Studierender mitbringen oder als Studierende, wenn ich in den KI-Studiengang mich einschreibe?


Der ist speziell, muss ich gleich sagen, weil unser Studiengang ist definitiv so aufgebaut, dass er multidisziplinär ist.


Das heißt, man muss natürlich einen Bachelorstudiengang vorher abgelegt haben, der aber in verschiedenen Domänen sein kann.


Das kann Wirtschaftswissenschaften sein, das kann Psychologie sein, das kann Ingenieurwesen sein, Informatik.


Und wir formen dann in dem Studiengang die Teams so, dass sie immer gemixt sind und dass dann ein Wissenstransfer zwischen den Couleuren stattfindet.


Entscheidend ist, dass ich Spaß an Technik habe.


Das ist halt das Entscheidende.


Ich darf keine Angst davor haben, auch mal die eine oder andere Zeile kurz zu schreiben.


Es ist nicht so wie das klassische Software Engineering,


weil wir eigentlich nur Buffetsketten aneinanderhängen und die Modelle wie Lego-Bausteine bauen oder zusammensetzen.


Aber man darf keine Ängste davor haben.


Wie tief steigen die Studierenden denn dann da ein?


Verstehen die am Ende wirklich, was sie da tun und können eigene Modelle trainieren, können vielleicht KI weiterentwickeln oder ist es eher auf so Anwendungsebene, dass sie dann eigene Apps bauen können?


Also ich hoffe, dass sie es verstehen.


Das liegt natürlich im Auge des Betrachters.


Nee, es ist tatsächlich so, dass die tatsächlich eigene Modelle bauen können, eigene Architekturen aufbauen können, eigene Modelle trainieren können in jeglicher Dimension.


Ist natürlich dann immer die Frage der Möglichkeiten, was dann, sagen wir mal, Peripherie, Hardware und so weiter da ist.


Aber von der Theorie und von den praktischen Projekten, die wir machen, ist jeder Student von uns fähig und jede Studentin dann auch tatsächlich eigene Modelle zu trainieren und aber auch das in einen Anwendungscase zu überführen.


Wenn quasi so ein Studiengang vorausgesetzt wird, um in den Master überhaupt einzusteigen, ist ja, das beantwortet eigentlich meine nächste Frage, ist es eigentlich immer ein Quereinstieg in Richtung KI?


Es ist überraschenderweise tatsächlich immer ein Quereinstieg bei uns.


Also es gibt andere Hochschulen, die haben tatsächlich den ganz klassischen Weg.


Ich habe erst ein Informatikstudium und dann gibt es halt eine Verschiebung über den Master im KI.


Das ist dann sozusagen, würde ich nennen, die Hardcore-Algorithmen-Entwickler, die im KI-Umfeld dann tätig sind.


Die bilden wir jetzt nicht so aus, weil wir einfach diese Iterationsschleifen über die Jahre nicht haben.


Im Endeffekt der Master mit drei Semestern, eineinhalb Jahre, gar nicht so in das Engineering in die Tiefe geht.


Was wir wollen ist, dass man die Fähigkeit hat und das vertiefen kann.


Das ist das eine.


Wie einfach ist es, aus dem Bereich wieder auszusteigen?


Kann ich danach auch als Softwareentwickler in einem ganz anderen Gebiet arbeiten oder ist das wirklich dann zu speziell?


Ich glaube gar nicht, dass es so speziell ist, weil wenn man sich jetzt so einen Prozess von so einem KI-Projekt anschaut, dann fängt es immer an mit einem Business Engineering, also Business Understanding herauszufinden, was will der Kunde oder was ist der Use Case, was wollen wir entwickeln.


Dann geht es rüber über ein Datenverständnis und dann rüber in die eigentliche Modellbildung.


und dann ins Deployment, und wenn ich jetzt in so einen klassischen Softwareentwicklungsprozess gehe, oder auch, es muss nicht mal Software sein, auch in ein normales Projektgeschäft, ich sag mal Prozesseinführung oder ähnliches, dann ist es auch Business Understanding, ich muss die Daten verstehen, dann kommt halt keine Modellbildung, dann kommt halt eher dann die Tätigkeit, die dort fällig ist, und am Ende muss ich aber auch dafür sorgen, dass das Projekt irgendwie in den operativen Betrieb übergeht,


Vielleicht jetzt nicht mit all den Mechanismen, die man im KI oder in der Softwareentwicklung hat, aber ich glaube, der Sprung ist gar nicht so schwer in andere Kolore zu kommen.


oder auch in anderen Bereichen zu arbeiten, sondern das ist eigentlich eher im Moment so, dass das passieren kann.


Also lässt sich die Arbeitsweise ganz gut übertragen?


Definitiv, ja.


Ich sage immer, man ist am Ende von einem KI-Projekt auch Domänexperte für die Systeme, wo man die KI entwickelt hat.


Weil man die Daten analysiert, versteht, wie das tickt und damit sich ja ganz tief auch mit dem Fachlichen auseinandersetzt, die in der Domäne gerade relevant sind.


Es ist eigentlich jetzt da das Gleiche nochmal, ne?


Also auch da, Domain-Wissen ist oft wichtiger, Domain- und Methodenwissen ist oft wichtiger als dann tatsächlich die eigentliche Fachexpertise an der Stelle.


Fand ich ganz spannend.


Boah, jetzt haben wir die zwei Stunden schon fast geknackt, hey.


Ich hab noch einen letzten Abschnitt für euch.


Den machen wir jetzt auch gleich noch.


Oder habt ihr dazu zum gerade Gesagten?


Ich will jetzt die zwei Stunden nicht noch mehr ausdehnen.


Mir ist nur aufgefallen, die Wörter Architektur und Modell, die kommen schon in sehr vielen verschiedenen Zusammenhängen und Bedeutungen vor heute in unserer Podcast-Serie.


Gut, dass wir da mal am Anfang erklärt haben, was es damit gemeint ist.


Okay, dann hier noch den letzten Abschnitt.


Wenn wir mal nach vorne gucken, was glaubst du, wie wird KI das Berufsbild von Softwareentwicklerinnen und Softwareentwicklern verändern?


Gibt es bald, wir haben gerade schon ganz kurz gestriffen, gibt es bald KI, die KI entwickelt?


Muss ich Coden überhaupt noch lernen oder muss ich eigentlich nur noch prompen?


Ja, es gibt ja schöne, da gibt es ganz viele Meinungen.


Gerne deine.


Meine Meinung ist, dass das Brompen tatsächlich ein ganz großes Thema ist, dass die zukünftige Programmiersprache eher Englisch sein wird, als irgendwie Java oder Python oder was auch immer.


Aber ich glaube auch, und das ist jetzt meine persönliche Meinung, Programmierkenntnisse gänzlich wegzulassen, ist, glaube ich, falsch.


Weil was man beim Programmieren ja lernt, ist ja nicht irgendwelche Befehle aneinanderzureihen oder irgendeine Sprache einfach nur, dass es die Syntaxe, die ich für die Sprache brauche, sondern ich gehe ja ganz häufig her und lerne sozusagen das Verständnis, das Problemzerlösen aus einem großen Problem, kleine Probleme mache, das dann aufzulösen, indem ich die kleinen Probleme dann umsetze in einer Programmiersprache und so weiter.


Und dieses Zerlegen eines großen Problems,


Das ist meiner Ansicht nach immer noch notwendig, auch später, auch wenn die KIs stärker sind, weil ansonsten verfolgt die KI ja nicht mehr unser Willen.


Also das ist unser Ziel, weil die kann ja unser Ziel nicht kennen.


Also von daher muss ich mein Problem schon in Häppchen zerlegen, um es dann der KI geben zu können, um meine Farbe noch drin zu haben.


Und dementsprechend bin ich der Meinung, das Programmieren, Lernen, vielleicht nicht mehr in allen Facetten, in allen Tiefen, aber es ist trotzdem noch relevant.


Jetzt klinge ich wie so ein düsterer Pessimist, der ich eigentlich gar nicht bin, aber ist das nicht auch eine Gefahr, dass, wenn wir uns dann wirklich nur noch aufs Prompten versteifen, dass dann irgendwann auch für Weiterentwicklungen einfach die Code-Basis fehlt, von der die KI wieder lernen kann?


Ja, das ist eine interessante Frage.


Weil das ist tatsächlich auch die Krux, wenn wir jetzt diese generativen KIs anschauen, die jetzt im Endeffekt mit Chat-GPT einfach auch die Plattformen fluten.


Dann landet irgendwann die KI von sich selber und wird nicht mehr besser.


Ist ein Risiko, definitiv.


Ist auch ein Grund, warum ich der Meinung bin, dass es nie aussterben wird, dass man nicht selber auch noch Hand anlegt.


Aber auf der anderen Seite muss man natürlich auch so sehen, dass auch eine KI ein Lehrer sein kann und sozusagen eine weitere KI anderen kann.


Und dann sozusagen, wie wir es ja als Lehrer auch machen, als Professoren, sind nicht so, dass die Studenten nur auf das Niveau von uns kommen, sondern die sind ja teilweise viel, viel besser als wir dann.


Das heißt, irgendwann entwickelt man sozusagen ein Eigenleben in so einer Welt.


Also könnte man sich auch vorstellen, dass KI sich selber sozusagen auch weitertrimmen können, um dann besser zu werden als die Ursprungs-KI.


Also deswegen ja und nein.


Bruno, du hast ein paar Mal den Kopf geschüttelt in dem letzten Abschnitt.


Ja, ich lehne mich jetzt da mal ganz weit aus dem Fenster und sage voraus, dass was sozusagen im Moment noch der KI fehlt, ist die Möglichkeit, rückzufragen.


Das heißt, diese ganze Idee mit diesem Prompt Engineering, die entsteht ja dadurch,


dass man jetzt feststellt, wenn man der KI irgendeine Frage stellt und die Frage ist nicht spezifisch genug, dann kriegt man eine Antwort, die keinen Sinn macht oder die einem nicht weiterhilft.


So, deswegen kommt man jetzt zu der Idee, ah, wie muss ich denn den Prompt formulieren, damit das rauskommt, was ich hinten haben will.


Ich glaube, das ist aber nur ein Zwischenschritt.


Ich glaube, dass es am Ende so, also was heißt am Ende, dass es sehr bald schon so sein wird,


dass die KI einfach Rückfragen stellt.


Wenn die Frage zu unspezifisch ist, müsste eigentlich eine Rückfrage kommen.


Hey, wie meinst du das?


Meinst du das mehr so oder mehr so oder mehr so?


Oder auch, dass die KI selber in der Lage ist, eben ein großes Problem in kleinere zu zerlegen, was ja zum Beispiel mit diesem Auto-GPT auch schon zum Teil automatisiert auch schon gemacht worden ist.


Und das Thema Rückfragen ist tatsächlich auch schon, das habe ich auch schon gesehen, wie Leute das in Ansätzen auch in Prompts quasi schon so integrieren.


Also, dass sie sagen, hey, wenn die Informationen fehlen, dann stell dazu Fragen.


Das funktioniert je nach Beispiel mal gut, mal schlecht.


Und es ist immer so ein bisschen so, ja, hat jetzt halt zufällig funktioniert.


Aber da wird auch schon, also glaube ich auch, dass das ein entscheidender Entwicklungsschritt sein wird.


Ja.


Was haben wir heute gelernt?


Frederik hat gelernt, dass es sehr viel praktischer ist, Informatik zu studieren, als er gedacht hätte.


Ja, und auch so aktuelle Themen, dass sie halt eben Scrum mit aufgreifen und dann auch tatsächlich da wirklich dieses Softwareprojekt dann mit Scrum Master und den verschiedenen Rollen im Team besetzen, finde ich echt mega interessant.


Und ich sagte ja auch, der Professor Dr.


Pfeiffer,


Prof.


Prawe sagte ja auch, dass das Softwareprojekt als der beliebtesten Studiengänge bei ihm ist und das kann ich durchaus verstehen, dass das sehr beliebt ist, weil das ja gerade diese Praxis, wie es in Formeln gelebt wird, widerspiegelt.


Das hat mich stark an so Planspiele erinnert, die man irgendwie auch in Wirtschaftszweigen in der Schule mal macht oder so, wo man Börse spielt.


Ja, es ist halt nicht so trocken, irgendwelche Begriffe oder Seiten aus Fachbüchern zu lernen und mehr gemeinsam mit anderen an einer Problemlösung zu arbeiten.


Und vor allem auch bewusst während der Ausbildung schon dieses Voneinanderlernen als Instrument auch zu etablieren.


Ich meine, das passiert ja oft sowieso automatisch, wenn erfahrene Leute mit weniger erfahrenen Leuten zusammenarbeiten, aber dass die das wirklich auch erkannt haben und auch bewusst so provozieren, das fand ich ganz spannend.


Das ist nicht schlecht.


Dann machen wir mal für heute den Deckel drauf, glaube ich.


Machen wir noch ganz schnell unsere Software-Picks, dann bleiben wir unter der Zwei-Stunden-Marke.


Mache ich gerne meinen Software-Pick.


Der hat auch mit KI zu tun, allerdings ein bisschen mit etwas Griffigerem.


Also man kann das daheim selber aufsetzen.


Das nennt sich, also eigentlich das darunterliegende Tool ist Easy Diffusion.


Kennen vielleicht schon einige.


Das ist letztlich eine Bildgenerierungs-KI.


kann man ganz lustige Sachen mitmachen, kann man Bilder mitgenerieren, kann man noch mal Kindern zeigen, wie so Bild KI funktioniert.


Und es gibt darauf aufgesetzt, und das ist das einzige Tool, was ich vorstelle, ist Easy Diffusion, das ist ein Projekt, das nutzt quasi Sable Diffusion und setzt sich selber auf.


Also man führt eigentlich nur noch einen Shell-Befehl aus,


und starte das Ding und man braucht eine fette Grafikkarte im Rechner oder eine halbwegs fähige Grafikkarte oder einen M1 oder M2 Macbook Chip.


Damit funktioniert es schon?


Damit funktioniert es auch, es dauert ein bisschen länger, es dauert so 1,5-2 Minuten pro Bild versus ein paar Sekunden mit einer dicken GPU drin.


Aber auch ein, zwei Minuten kann man mal abwarten und dann generiert er was Schönes und das ist ganz nett, bringt eine Oberfläche mit, also startet dann so einen Webbrowser intern und dann kann man dort Bilder prompten und mit verschiedenen Schalterchen noch arbeiten, kann man ein bisschen rumspielen mit und kann dann eben mit einer Bilder-KI erste Gehversuche starten.


Easy Diffusion.


Wir werden es bestimmt in den Show Notes verlinken.


Auf jeden Fall.


Bodo?


Ja, ich habe was ganz Simples, was eigentlich schon früher immer im Mac OS eingebaut war, nämlich ich habe ab und zu bald das Problem, dass ich mehrere Seiten in einer Broschüre ausdrucken will.


Das heißt also normale DIN A4 Seiten auf DIN A5 runterverkleinern, aber die so als Broschüre drucken, dass wenn ich die nacheinander drucke und sie dann in der Mitte klammere und dann zusammenfalte,


in der Mitte, dass ich dann eben so eine buchähnliche Seitenfolge habe.


Also diese Sortierung dieser Seiten so zu machen.


Vor einigen Jahren habe ich das entdeckt, dass es in iOS, also auf dem MacBook, dass es tatsächlich diese Funktion gibt in dem ganz normalen Druckmenü.


Aber seit der letzten Version ist sie verschwunden.


Und jetzt hatte ich das Problem vorgestern nieder.


Du warst wahrscheinlich der einzige Mensch, der die benutzt hat.


Jetzt hatte ich das Problem vorgestern nieder und ich habe es einfach nicht mehr gefunden.


Ich habe es gegoogelt und alle sagen, ja, das gibt es an der und der Stelle im Druckmenü, aber es ist weg.


Aber ich habe dann gefunden, der Acrobat Reader hat es noch und deswegen habe ich mir Acrobat Reader installiert und der hat Broschürendruck.


Also für alle, die mal eine Broschüre drucken wollen.


Also jetzt wirklich den Acrobat Reader hier als Software-Pick loslassen?


Das kommt für eine spezielle Funktion.


Das kommt gleich nach Internet Explorer.


Ah, nein.


Ja, aber das war das Beste und das Schnellste, was ich gefunden habe.


Ich war auch überrascht.


Okay, was hast du, Jürgen?


Ich mache einfach mal einen Shoutout an meine Go-To-Podcast-Schneide-Software, weil das einfach ein geiles Projekt ist.


Also ich verwende für die Aufnahme und für den Schnitt für die Produktion komplett eigentlich Reaper, das man aus der Musikproduktion kennt, aber zusammen mit dem Plugin Ultraschall, das aus der deutschen Podcast-Community kommt.


Und das ist ein Wahnsinnsprojekt, das schon seit ganz vielen Jahren unterwegs ist.


Da ist jetzt Version 5 schon draußen.


Die 6 steht schon, glaube ich, fast in den Startlöchern, wenn ich es richtig auf dem Schirm habe.


Und fand ich toll genug, dass ich mich damit eingeklinkt habe und an der Dokumentation mitgeschrieben habe.


Also ist ein Open-Source-Projekt.


Also ganz großartiges Ding.


Macht richtig Spaß, damit zu arbeiten, auch nach Jahren noch.


Ich wusste schon tatsächlich, dass ich mit dieser Software Podcasts aufnehmen und schneiden will, bevor ich wieder angefangen habe, Podcasts aufzunehmen.


Also ich hatte die Software schon, bevor ich den Podcast hatte, sozusagen.


Großartig.


Gut, dann haben wir es gerade so unter die zwei Stunden, glaube ich, geschafft, wenn ich ein paar Pausen rausschneide.


Jetzt sind wir bei zwei Stunden eins.


Okay.


Und dann hören wir uns beim nächsten Mal.


Tschüss.


Alles klar.


Sehr gut.


Danke nochmal auf jeden Fall an Professor Pfeiffer und Professor Dr.


Sigurd Schacht.


Die werde ich auch nochmal anpingen, dass sie das auf jeden Fall mitbekommen.


Vielen Dank, dass die uns hier so ausführlich Rede und Antwort gestanden haben.


Ich bin Jürgen Kraus, wir sind Branded und das ist Schwarz-Kote-Gold.


Das war's dann.


Sehr geehrte Podcast-Hörerin, sehr geehrter Podcast-Hörer, hiermit bewerben wir uns als dein nächster Arbeitgeber.


Ja, ich weiß schon, dass das normalerweise andersrum läuft, aber ich finde, dass sich Unternehmen heutzutage durchaus etwas reinhängen müssen, wenn es um neue Mitarbeitende geht.


Falls du also Scrum Master bist oder viel Erfahrung hast mit Fullstack, Backend oder Frontend Entwicklung, dann freue ich mich über eine kurze Nachricht an jobs at branded.dev und dann schicke ich super gerne unsere Bewerbungsunterlagen einschließlich Anschreiben, Lebenslauf und Fotos zu dir.


Bis hoffentlich bald und mit den allerbesten Grüßen von deinen neuen Kolleginnen und Kollegen von Branded.